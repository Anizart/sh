use16
org 100h

    jmp start

;-- Данные ----------------------------------------------------------
msg_input  db 'Enter 8 digits (use - for negative):', 13, 10, '$'
msg_orig   db 13, 10, 'Original array: ', '$'
msg_res    db 13, 10, 'Result (positives replaced by 0): ', '$'
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$'

array      db 8 dup(0)
count      dw 8
;--------------------------------------------------------------------

start:
    ; 1. Ввод исходного массива
    mov ah, 09h
    mov dx, msg_input
    int 21h

    mov cx, [count]
    mov bx, array
input_loop:
    mov ah, 01h
    int 21h
    cmp al, '-'         ; Если введен минус, читаем цифру как отрицательную
    jne .pos
    int 21h
    sub al, '0'
    neg al
    jmp .save
.pos:
    sub al, '0'
.save:
    mov [bx], al        ; Сохранение в массив
    inc bx
    mov ah, 02h         ; Пробел
    mov dl, ' '
    int 21h
    loop input_loop

    ; 2. Вывод оригинального массива
    mov ah, 09h
    mov dx, msg_orig
    int 21h
    call print_array

    ; 3. Обработка массива: замена положительных на 0
    mov cx, [count]
    mov bx, array
process_loop:
    cmp byte [bx], 0    ; Сравниваем элемент с нулем
    jle .skip           ; Если <= 0 (Jump if Less or Equal), пропускаем
    
    mov byte [bx], 0    ; Если > 0, записываем 0 по адресу в BX

.skip:
    inc bx              ; Переход к следующему байту
    loop process_loop

    ; 4. Вывод итогового массива
    mov ah, 09h
    mov dx, msg_res
    int 21h
    call print_array

    ; 5. Выход
    mov ah, 09h
    mov dx, msg_pause
    int 21h
    mov ah, 08h         ; Пауза
    int 21h
    mov ax, 4C00h       ; Завершение
    int 21h

;-- Подпрограмма вывода массива -------------------------------------
print_array:
    push cx
    push bx
    mov cx, [count]
    mov bx, array
.lp:
    mov al, [bx]
    cmp al, 0
    jge .p
    push ax
    mov dl, '-'
    mov ah, 02h
    int 21h
    pop ax
    neg al
.p:
    add al, '0'         ; ASCII преобразование
    mov dl, al
    mov ah, 02h
    int 21h
    mov dl, ' '
    int 21h
    inc bx
    loop .lp
    pop bx
    pop cx
    ret


! Описание:
Goto: 17F

! Вводи: 3 -2 5 0 -1 7 4 -8

! Как работает:

use16                   ; Использовать 16-битный режим (стандарт для DOS)
org 100h                ; Начало программы с адреса 100h (структура .COM файла)

    jmp start           ; Прыжок на метку start, чтобы пропустить блок описания данных

;-- Блок данных в оперативной памяти --------------------------------
msg_input  db 'Enter 8 digits (use - for negative):', 13, 10, '$' ; Строка-приглашение
msg_orig   db 13, 10, 'Original array: ', '$'        ; Текст перед выводом оригинала
msg_res    db 13, 10, 'Result (positives replaced by 0): ', '$' ; Текст перед выводом результата
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$' ; Сообщение паузы

array      db 8 dup(0)  ; Выделяем 8 байт (ячеек) памяти, инициализируем их нулями
count      dw 8         ; Размер массива (количество элементов)
;--------------------------------------------------------------------

start:
    ; 1. Ввод исходного массива с клавиатуры
    mov ah, 09h         ; Функция DOS 09h: вывести строку на экран
    mov dx, msg_input   ; Записываем адрес строки msg_input в регистр DX
    int 21h             ; Вызов прерывания — печать текста

    mov cx, [count]     ; Загружаем в CX число 8 (количество повторов цикла)
    mov bx, array       ; Записываем адрес начала массива в регистр BX (указатель)
input_loop:
    mov ah, 01h         ; Функция DOS 01h: ввод символа с клавиатуры (в AL)
    int 21h             ; Ждем ввода. Код символа попадает в регистр AL
    
    cmp al, '-'         ; Сравниваем введенный символ с кодом минуса
    jne .pos            ; Если ввели НЕ минус (Jump if Not Equal), идем к обработке цифры
    int 21h             ; Если ввели минус, вызываем ввод еще раз для самой цифры
    sub al, '0'         ; Превращаем ASCII-код ('5' = 53) в реальное число (5)
    neg al              ; Меняем знак числа в AL на отрицательный (5 -> -5)
    jmp .save           ; Прыгаем к сохранению, пропуская положительный блок
.pos:
    sub al, '0'         ; Превращаем ASCII-код положительной цифры в число
.save:
    mov [bx], al        ; Записываем полученное число из AL в память по адресу в BX
    inc bx              ; Сдвигаем указатель BX на 1 байт вперед (к следующей ячейке)
    
    mov ah, 02h         ; Функция DOS 02h: вывод одного символа
    mov dl, ' '         ; Кладем символ пробела в DL
    int 21h             ; Печать пробела (для разделения вводимых цифр)
    loop input_loop     ; Уменьшаем CX. Если CX > 0, прыгаем на начало input_loop

    ; 2. Вывод оригинального (введенного) массива
    mov ah, 09h         ; Функция вывода заголовка "Original array"
    mov dx, msg_orig
    int 21h
    call print_array    ; Вызываем подпрограмму для вывода элементов массива

    ; 3. Обработка массива: замена положительных элементов на 0
    mov cx, [count]     ; Снова устанавливаем счетчик цикла на 8
    mov bx, array       ; Снова ставим указатель BX на начало массива
process_loop:
    ; Команда сравнения: вычитает 0 из значения в памяти, но не меняет его, 
    ; только выставляет флаги состояния процессора.
    cmp byte [bx], 0    ; Сравниваем текущий байт в массиве с нулем
    
    ; JLE (Jump if Less or Equal) — прыжок, если значение <= 0.
    ; Положительными считаются числа СТРОГО больше нуля.
    jle .skip           ; Если число отрицательное или ноль — ничего не делаем, прыгаем в конец
    
    ; Если мы здесь, значит число было положительным (> 0)
    mov byte [bx], 0    ; Записываем число 0 в текущую ячейку памяти по адресу BX

.skip:
    inc bx              ; Перемещаем указатель BX на следующий байт массива
    loop process_loop   ; Повторяем цикл для всех 8 элементов

    ; 4. Вывод измененного массива
    mov ah, 09h         ; Печать заголовка "Result..."
    mov dx, msg_res
    int 21h
    call print_array    ; Вызов подпрограммы (теперь положительные числа стали нулями)

    ; 5. Выход из программы
    mov ah, 09h         ; Печать сообщения о паузе
    mov dx, msg_pause
    int 21h
    mov ah, 08h         ; Функция DOS 08h: чтение клавиши без эха (пауза)
    int 21h
    mov ax, 4C00h       ; Функция 4Ch: завершить программу с кодом 0
    int 21h

;-- Подпрограмма вывода массива -------------------------------------
print_array:
    push cx             ; Сохраняем CX в стек (защита данных основного цикла)
    push bx             ; Сохраняем BX в стек
    mov cx, [count]     ; Настраиваем цикл на 8 повторений
    mov bx, array       ; Начинаем печатать с начала массива
.lp:
    mov al, [bx]        ; Читаем число из массива в регистр AL
    cmp al, 0           ; Проверяем: число меньше нуля?
    jge .p              ; Если >= 0, идем к метке .p (печать цифры)
    
    push ax             ; Если число отрицательное, сохраняем его
    mov dl, '-'         ; Сначала печатаем знак минуса
    mov ah, 02h
    int 21h
    pop ax              ; Достаем число обратно в AL
    neg al              ; Делаем число положительным для корректного вывода цифры
.p:
    add al, '0'         ; Конвертируем число в ASCII-код цифры (например, 5 -> '5')
    mov dl, al          ; Перемещаем символ в DL для вывода
    mov ah, 02h         ; Функция печати символа
    int 21h
    
    mov dl, ' '         ; Печать пробела после каждой цифры
    int 21h
    inc bx              ; Сдвигаем указатель к следующему элементу массива
    loop .lp            ; Крутим цикл печати
    pop bx              ; Восстанавливаем сохраненный BX из стека
    pop cx              ; Восстанавливаем сохраненный CX из стека
    ret                 ; Возвращаемся в точку, откуда вызвали print_array
