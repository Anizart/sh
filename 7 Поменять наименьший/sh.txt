use16
org 100h

    jmp start

;-- Данные ----------------------------------------------------------
msg_input  db 'Enter 8 single digits (use - for negative):', 13, 10, '$'
msg_orig   db 13, 10, 'Original array: ', '$'
msg_res    db 13, 10, 'Result (swapped min and first): ', '$'
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$'

array      db 8 dup(0)
count      dw 8
;--------------------------------------------------------------------

start:
    ; 1. Ввод массива (8 элементов)
    mov ah, 09h
    mov dx, msg_input
    int 21h

    mov cx, [count]     ; Счётчик цикла
    mov bx, array
input_loop:
    mov ah, 01h         ; Функция ввода символа
    int 21h
    
    cmp al, '-'         ; Обработка отрицательных чисел
    jne .pos
    int 21h             ; Читаем цифру после минуса
    sub al, '0'
    neg al
    jmp .save
.pos:
    sub al, '0'
.save:
    mov [bx], al        ; Сохраняем в массив
    inc bx
    
    mov ah, 02h         ; Пробел
    mov dl, ' '
    int 21h
    loop input_loop

    ; 2. Вывод оригинального массива
    mov ah, 09h
    mov dx, msg_orig
    int 21h
    call print_array

    ; 3. Поиск минимального элемента
    mov cx, [count]
    mov bx, array
    mov al, [bx]        ; Пусть первый элемент — минимальный
    mov di, bx          ; DI будет хранить адрес минимального элемента

find_min:
    mov dl, [bx]        ; Текущий элемент
    cmp dl, al          ; Сравниваем текущий с минимальным
    jl .new_min         ; Если текущий меньше, переходим к обновлению
    jmp .next

.new_min:
    mov al, dl          ; Обновляем значение минимума
    mov di, bx          ; Запоминаем адрес нового минимума

.next:
    inc bx
    loop find_min

    ; 4. Обмен значениями (Swap)
    ; DI указывает на минимальный элемент, array — на первый
    mov bx, array       ; Адрес первого элемента
    mov al, [bx]        ; AL = значение первого элемента
    mov dl, [di]        ; DL = значение минимального элемента

    mov [bx], dl        ; Записываем минимум в начало массива
    mov [di], al        ; Записываем бывший первый элемент на место минимума

    ; 5. Вывод итогового массива
    mov ah, 09h
    mov dx, msg_res
    int 21h
    call print_array

    ; 6. Пауза и выход
    mov ah, 09h
    mov dx, msg_pause
    int 21h
    mov ah, 08h         ; Ожидание нажатия клавиши
    int 21h
    mov ax, 4C00h       ; Завершение
    int 21h

;-- Подпрограмма вывода массива -------------------------------------
print_array:
    push cx
    push bx
    mov cx, [count]
    mov bx, array
.lp:
    mov al, [bx]
    cmp al, 0
    jge .p
    push ax
    mov dl, '-'         ; Вывод знака '-'
    mov ah, 02h
    int 21h
    pop ax
    neg al
.p:
    add al, '0'         ; Преобразование числа в ASCII
    mov dl, al
    mov ah, 02h
    int 21h
    mov dl, ' '         ; Пробел между числами
    int 21h
    inc bx
    loop .lp
    pop bx
    pop cx
    ret


! Описание:
Goto: 16E

! Вводи: 5 2 8 -3 0 7 1 4

! Как работает:

use16                   ; Использовать 16-битный режим (стандарт для DOS)
org 100h                ; Начало программы со смещения 100h (структура .COM)

    jmp start           ; Прыжок на метку start, чтобы пропустить данные

;-- Блок данных в оперативной памяти --------------------------------
msg_input  db 'Enter 8 single digits (use - for negative):', 13, 10, '$' ; Приглашение
msg_orig   db 13, 10, 'Original array: ', '$'        ; Текст для оригинала
msg_res    db 13, 10, 'Result (swapped min and first): ', '$' ; Текст для результата
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$' ; Текст паузы

array      db 8 dup(0)  ; Выделяем 8 байт под массив, заполняем нулями
count      dw 8         ; Размер массива
;--------------------------------------------------------------------

start:
    ; 1. Ввод массива (8 элементов)
    mov ah, 09h         ; Функция DOS 09h: печать строки из DX
    mov dx, msg_input   ; Загружаем адрес строки в DX
    int 21h             ; Системный вызов

    mov cx, [count]     ; Загружаем 8 в счетчик циклов CX
    mov bx, array       ; Устанавливаем указатель BX на начало массива
input_loop:
    mov ah, 01h         ; Функция DOS 01h: ввод символа
    int 21h             ; Код символа попадает в AL
    
    cmp al, '-'         ; Проверяем, ввели ли минус
    jne .pos            ; Если нет, прыгаем на обработку положительного числа
    int 21h             ; Если минус, вводим следующий символ (цифру)
    sub al, '0'         ; Переводим символ в число ('5' -> 5)
    neg al              ; Делаем число отрицательным (5 -> -5)
    jmp .save           ; Идем на сохранение
.pos:
    sub al, '0'         ; Конвертируем ASCII символ цифры в число
.save:
    mov [bx], al        ; Записываем число из AL в память по адресу BX
    inc bx              ; Переходим к следующему байту в памяти
    
    mov ah, 02h         ; Функция DOS 02h: вывод одного символа
    mov dl, ' '         ; Печатаем пробел для красоты
    int 21h
    loop input_loop     ; Повторяем, пока не введем 8 чисел

    ; 2. Вывод оригинального массива
    mov ah, 09h
    mov dx, msg_orig
    int 21h
    call print_array    ; Вызов подпрограммы печати

    ; 3. Поиск минимального элемента
    mov cx, [count]     ; Снова настраиваем цикл на 8 итераций
    mov bx, array       ; BX указывает на начало массива
    mov al, [bx]        ; Берем первый элемент как "эталонный" минимум
    mov di, bx          ; В DI сохраняем АДРЕС этого первого элемента

find_min:
    mov dl, [bx]        ; Загружаем текущий элемент из памяти в DL
    cmp dl, al          ; Сравниваем текущий (DL) с минимальным (AL)
    jl .new_min         ; Если текущий МЕНЬШЕ (Jump if Less), идем обновлять
    jmp .next           ; Иначе идем к следующему шагу

.new_min:
    mov al, dl          ; Обновляем минимальное значение в AL
    mov di, bx          ; Обновляем АДРЕС минимального элемента в DI

.next:
    inc bx              ; Сдвигаем BX на следующий элемент
    loop find_min       ; Повторяем для всего массива

    ; 4. Обмен значениями (Swap)
    ; DI сейчас хранит АДРЕС минимального элемента
    ; array — это адрес ПЕРВОГО элемента
    mov bx, array       ; Кладем в BX адрес начала массива
    mov al, [bx]        ; Копируем значение первого элемента в AL
    mov dl, [di]        ; Копируем значение минимального элемента в DL

    mov [bx], dl        ; Записываем минимальное значение в первую ячейку
    mov [di], al        ; Записываем бывшее первое значение туда, где был минимум

    ; 5. Вывод итогового массива
    mov ah, 09h
    mov dx, msg_res
    int 21h
    call print_array    ; Печатаем массив после изменений

    ; 6. Пауза и выход
    mov ah, 09h
    mov dx, msg_pause
    int 21h
    mov ah, 08h         ; Ожидание нажатия клавиши
    int 21h
    mov ax, 4C00h       ; Завершение программы
    int 21h

;-- Подпрограмма вывода массива -------------------------------------
print_array:
    push cx             ; Сохраняем CX и BX в стек, чтобы не испортить их
    push bx
    mov cx, [count]     ; Цикл на 8 раз
    mov bx, array       ; С начала массива
.lp:
    mov al, [bx]        ; Берем число
    cmp al, 0           ; Проверяем знак
    jge .p              ; Если положительное, идем печатать цифру
    push ax             ; Если отрицательное — сначала печатаем '-'
    mov dl, '-'
    mov ah, 02h
    int 21h
    pop ax
    neg al              ; Инвертируем число для вывода самой цифры
.p:
    add al, '0'         ; Число -> ASCII
    mov dl, al
    mov ah, 02h
    int 21h             ; Печать
    mov dl, ' '         ; Пробел
    int 21h
    inc bx              ; Следующий элемент
    loop .lp            ; Крутим цикл
    pop bx              ; Восстанавливаем регистры
    pop cx
    ret                 ; Выход из подпрограммы

