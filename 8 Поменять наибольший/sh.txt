use16
org 100h

    jmp start

;-- Данные ----------------------------------------------------------
msg_input  db 'Enter 8 single digits (use - for negative):', 13, 10, '$'
msg_orig   db 13, 10, 'Original array: ', '$'
msg_res    db 13, 10, 'Result (swapped max and last): ', '$'
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$'

array      db 8 dup(0)
count      dw 8
;--------------------------------------------------------------------

start:
    ; 1. Ввод массива
    mov ah, 09h
    mov dx, msg_input
    int 21h

    mov cx, [count]     ; Счётчик цикла
    mov bx, array
input_loop:
    mov ah, 01h         ; Ввод символа
    int 21h
    cmp al, '-'         ; Если минус, обрабатываем отрицательное
    jne .pos
    int 21h
    sub al, '0'
    neg al
    jmp .save
.pos:
    sub al, '0'
.save:
    mov [bx], al        ; Сохраняем в память
    inc bx
    mov ah, 02h         ; Вывод пробела
    mov dl, ' '
    int 21h
    loop input_loop

    ; 2. Вывод оригинала
    mov ah, 09h
    mov dx, msg_orig
    int 21h
    call print_array

    ; 3. Поиск наибольшего элемента
    mov cx, [count]
    mov bx, array
    mov al, [bx]        ; Принимаем первый элемент за максимум
    mov di, bx          ; DI хранит адрес текущего максимума

find_max:
    mov dl, [bx]
    cmp dl, al          ; Сравниваем текущий с максимальным
    jg .new_max         ; Если текущий больше (Jump if Greater), обновляем
    jmp .next

.new_max:
    mov al, dl          ; Новое значение максимума
    mov di, bx          ; Новый адрес максимума

.next:
    inc bx
    loop find_max

    ; 4. Обмен (Swap) максимума с последним элементом
    ; DI указывает на максимум. Найдем адрес последнего:
    mov si, array
    add si, [count]
    dec si              ; SI указывает на последний байт

    mov al, [di]        ; AL = значение максимума
    mov dl, [si]        ; DL = значение последнего элемента

    mov [di], dl        ; Последний кладем на место максимума
    mov [si], al        ; Максимум кладем в конец

    ; 5. Вывод результата
    mov ah, 09h
    mov dx, msg_res
    int 21h
    call print_array

    ; 6. Выход
    mov ah, 09h
    mov dx, msg_pause
    int 21h
    mov ah, 08h         ; Пауза
    int 21h
    mov ax, 4C00h       ; Завершение
    int 21h

;-- Подпрограмма вывода массива -------------------------------------
print_array:
    push cx
    push bx
    mov cx, [count]
    mov bx, array
.lp:
    mov al, [bx]
    cmp al, 0
    jge .p
    push ax
    mov dl, '-'         ; Вывод знака '-'
    mov ah, 02h
    int 21h
    pop ax
    neg al
.p:
    add al, '0'
    mov dl, al
    mov ah, 02h
    int 21h
    mov dl, ' '
    int 21h
    inc bx
    loop .lp
    pop bx
    pop cx
    ret


! Описание:
Goto: 183

! Вводи: 1 9 2 3 4 5 6 7

! Как работает:

use16                   ; Использовать 16-битный режим (DOS)
org 100h                ; Смещение 100h — стандарт для программ .COM в памяти

    jmp start           ; Перепрыгнуть блок данных, чтобы процессор не начал их исполнять

;-- Блок данных в оперативной памяти --------------------------------
msg_input  db 'Enter 8 single digits (use - for negative):', 13, 10, '$' ; Строка-приглашение
msg_orig   db 13, 10, 'Original array: ', '$'             ; Заголовок для вывода оригинала
msg_res    db 13, 10, 'Result (swapped max and last): ', '$' ; Заголовок для результата
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$' ; Текст паузы

array      db 8 dup(0)  ; Выделяем 8 байт под массив, заполняем нулями
count      dw 8         ; Переменная, хранящая размер массива (8)
;--------------------------------------------------------------------

start:
    ; 1. Ввод массива с клавиатуры
    mov ah, 09h         ; Функция DOS 09h: вывод строки на экран
    mov dx, msg_input   ; Загружаем адрес сообщения в регистр DX
    int 21h             ; Вызов прерывания DOS — печать текста

    mov cx, [count]     ; Записываем 8 в CX — это счетчик итераций для цикла ввода
    mov bx, array       ; BX — регистр-указатель, ставим его на начало массива
input_loop:
    mov ah, 01h         ; Функция DOS 01h: ввод 1 символа с клавиатуры
    int 21h             ; Код символа (ASCII) попадает в регистр AL
    
    cmp al, '-'         ; Проверяем: ввел ли пользователь знак минус?
    jne .pos            ; Если не равно (Jump if Not Equal), прыгаем на .pos
    int 21h             ; Если был минус, считываем саму цифру в AL следующим вызовом
    sub al, '0'         ; Превращаем ASCII-символ (например, '5') в число (5)
    neg al              ; Инвертируем знак числа (5 превращается в -5)
    jmp .save           ; Прыгаем к сохранению, пропуская положительную обработку
.pos:
    sub al, '0'         ; Конвертируем положительный символ цифры в реальное число
.save:
    mov [bx], al        ; Записываем число из AL в ячейку памяти по адресу в BX
    inc bx              ; Сдвигаем указатель BX на 1 байт вперед (к следующей ячейке)
    
    mov ah, 02h         ; Функция DOS 02h: вывод одного символа на экран
    mov dl, ' '         ; Выводим пробел между вводами для удобства
    int 21h             ; Системный вызов печати пробела
    loop input_loop     ; Уменьшаем CX. Если CX > 0, идем на начало цикла ввода

    ; 2. Вывод оригинального массива (для контроля)
    mov ah, 09h         ; Печать заголовка msg_orig
    mov dx, msg_orig
    int 21h
    call print_array    ; Вызов подпрограммы печати текущего состояния массива

    ; 3. Поиск наибольшего элемента (Максимума)
    mov cx, [count]     ; Снова настраиваем цикл на 8 итераций
    mov bx, array       ; Снова ставим BX на начало массива
    mov al, [bx]        ; Читаем первый элемент. Пусть он пока будет самым большим
    mov di, bx          ; В регистре DI запоминаем АДРЕС этого первого элемента

find_max:
    mov dl, [bx]        ; Читаем текущий байт из памяти (адрес в BX) в регистр DL
    cmp dl, al          ; Сравниваем текущий элемент (DL) с текущим максимумом (AL)
    jg .new_max         ; Если текущий больше (Jump if Greater), прыгаем на обновление
    jmp .next           ; Иначе идем дальше

.new_max:
    mov al, dl          ; Обновляем значение максимума в AL
    mov di, bx          ; Обновляем адрес самого большого элемента в DI

.next:
    inc bx              ; Сдвигаем BX к следующему элементу массива
    loop find_max       ; Повторяем, пока не проверим все 8 элементов

    ; 4. Обмен (Swap) найденного максимума с последним элементом
    ; DI сейчас хранит адрес максимума. Теперь найдем адрес последнего байта:
    mov si, array       ; Записываем адрес начала массива в SI
    add si, [count]     ; Прибавляем 8 (длину). Теперь SI указывает за пределы массива
    dec si              ; Вычитаем 1. Теперь SI указывает на ПОСЛЕДНИЙ (8-й) байт

    mov al, [di]        ; Копируем ЗНАЧЕНИЕ максимума из памяти в регистр AL
    mov dl, [si]        ; Копируем ЗНАЧЕНИЕ последнего элемента из памяти в регистр DL

    mov [di], dl        ; Записываем последнее число в ту ячейку, где раньше был максимум
    mov [si], al        ; Записываем максимум в самую последнюю ячейку массива

    ; 5. Вывод измененного массива
    mov ah, 09h         ; Печать заголовка msg_res
    mov dx, msg_res
    int 21h
    call print_array    ; Печать массива после обмена

    ; 6. Завершение
    mov ah, 09h         ; Вывод сообщения о паузе
    mov dx, msg_pause
    int 21h
    mov ah, 08h         ; Ждем нажатия любой клавиши
    int 21h
    mov ax, 4C00h       ; Корректное завершение программы
    int 21h

;-- Подпрограмма вывода массива -------------------------------------
print_array:
    push cx             ; Сохраняем CX в стек, чтобы не испортить счетчик основного цикла
    push bx             ; Сохраняем BX
    mov cx, [count]     ; Настраиваем цикл вывода на 8 раз
    mov bx, array       ; Начинаем печатать с начала массива
.lp:
    mov al, [bx]        ; Читаем число из памяти в AL
    cmp al, 0           ; Проверяем, отрицательное оно или нет
    jge .p              ; Если >= 0, идем печатать цифру
    push ax             ; Если < 0, сохраняем AX
    mov dl, '-'         ; Сначала печатаем символ '-'
    mov ah, 02h
    int 21h
    pop ax              ; Достаем число обратно
    neg al              ; Превращаем отрицательное в положительное для вывода цифры
.p:
    add al, '0'         ; Конвертируем число в ASCII-символ
    mov dl, al          ; Перемещаем в DL для вывода
    mov ah, 02h         ; Печать одного символа
    int 21h
    mov dl, ' '         ; Вывод пробела после цифры
    int 21h
    inc bx              ; Сдвигаем указатель к следующему числу
    loop .lp            ; Повторяем цикл
    pop bx              ; Восстанавливаем BX из стека
    pop cx              ; Восстанавливаем CX из стека
    ret                 ; Возвращаемся в точку вызова подпрограммы
