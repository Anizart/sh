use16
org 100h

    jmp start

;-- Данные ----------------------------------------------------------
msg_input  db 'Enter 8 digits (use - for negative):', 13, 10, '$'
msg_orig   db 13, 10, 'Original array: ', '$'
msg_res    db 13, 10, 'Product (first negative * last): ', '$'
msg_none   db 13, 10, 'No negative elements found!', '$'
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$'

array      db 8 dup(0)
count      dw 8
;--------------------------------------------------------------------

start:
    ; 1. Ввод массива
    mov ah, 09h
    mov dx, msg_input
    int 21h

    mov cx, [count]
    mov bx, array
input_loop:
    mov ah, 01h
    int 21h
    cmp al, '-'         
    jne .pos
    int 21h
    sub al, '0'
    neg al
    jmp .save
.pos:
    sub al, '0'
.save:
    mov [bx], al
    inc bx
    mov ah, 02h
    mov dl, ' '
    int 21h
    loop input_loop

    ; 2. Поиск первого отрицательного элемента
    mov cx, [count]
    mov bx, array
find_neg:
    mov al, [bx]
    cmp al, 0
    jl found_neg        ; Если нашли (Jump if Less), идем к умножению
    inc bx
    loop find_neg

    ; Если отрицательных нет
    mov ah, 09h
    mov dx, msg_none
    int 21h
    jmp exit

found_neg:
    ; AL уже содержит первый отрицательный элемент
    ; 3. Умножение на последний элемент
    mov si, array
    add si, [count]
    dec si              ; SI указывает на последний элемент массива
    
    mov dl, [si]        ; DL = последний элемент
    imul dl             ; AX = AL * DL (знаковое умножение)
    
    mov bx, ax          ; Сохраняем результат в BX для вывода

    ; 4. Вывод результата
    mov ah, 09h
    mov dx, msg_res
    int 21h
    
    mov ax, bx
    call print_num_ax

exit:
    mov ah, 09h
    mov dx, msg_pause
    int 21h
    mov ah, 08h
    int 21h
    mov ax, 4C00h
    int 21h

;-- Процедура вывода числа в AX (с учетом знака) ---------------------
print_num_ax:
    test ax, ax
    jns .positive
    push ax
    mov dl, '-'
    mov ah, 02h
    int 21h
    pop ax
    neg ax
.positive:
    xor cx, cx
    mov bx, 10
.div_loop:
    xor dx, dx
    div bx
    push dx
    inc cx
    test ax, ax
    jnz .div_loop
.print_loop:
    pop dx
    add dl, '0'
    mov ah, 02h
    int 21h
    loop .print_loop
    ret


! Описание:
Goto: 19C

! Вводи: 3 5 -2 4 0  1 7 6

! Как работает:

use16                   ; Указываем использовать 16-битный режим (DOS)
org 100h                ; Программа начинается с адреса 100h (формат .COM)

    jmp start           ; Перепрыгиваем блок данных, чтобы начать выполнение кода

;-- Данные в оперативной памяти -------------------------------------
msg_input  db 'Enter 8 digits (use - for negative):', 13, 10, '$' ; Приглашение
msg_orig   db 13, 10, 'Original array: ', '$'        ; Заголовок оригинала
msg_res    db 13, 10, 'Product (first negative * last): ', '$' ; Заголовок результата
msg_none   db 13, 10, 'No negative elements found!', '$' ; Если нет отрицательных
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$' ; Текст паузы

array      db 8 dup(0)  ; Выделяем 8 байт под массив, заполняем нулями
count      dw 8         ; Размер массива (количество байт)
;--------------------------------------------------------------------

start:
    ; 1. Ввод массива с клавиатуры
    mov ah, 09h         ; Функция DOS 09h: вывод строки на экран
    mov dx, msg_input   ; Загружаем адрес сообщения в DX
    int 21h             ; Вызов DOS для печати

    mov cx, [count]     ; Загружаем 8 в счетчик циклов CX
    mov bx, array       ; BX — указатель на начало массива (адрес первой ячейки)
input_loop:
    mov ah, 01h         ; Функция DOS 01h: ввод 1 символа с эхом (результат в AL)
    int 21h             ; Программа ждет нажатия клавиши
    cmp al, '-'         ; Проверяем, ввел ли пользователь минус
    jne .pos            ; Если не минус (Jump Not Equal), идем к обработке цифры
    int 21h             ; Если был минус, считываем саму цифру в AL
    sub al, '0'         ; Переводим ASCII символ (например '5') в число (5)
    neg al              ; Делаем число отрицательным (5 -> -5)
    jmp .save           ; Прыгаем к сохранению, минуя блок положительного числа
.pos:
    sub al, '0'         ; Конвертируем символ цифры в число для положительного ввода
.save:
    mov [bx], al        ; Записываем полученное число из регистра AL в ячейку по адресу BX
    inc bx              ; Перемещаем указатель BX на следующий байт массива
    mov ah, 02h         ; Функция DOS 02h: вывод одного символа
    mov dl, ' '         ; Выводим пробел для визуального разделения ввода
    int 21h             
    loop input_loop     ; Уменьшаем CX. Если CX > 0, прыгаем в начало цикла

    ; 2. Поиск первого отрицательного элемента
    mov cx, [count]     ; Снова устанавливаем счетчик цикла на 8
    mov bx, array       ; Указываем BX на начало массива
find_neg:
    mov al, [bx]        ; Читаем текущий байт из памяти в регистр AL
    cmp al, 0           ; Сравниваем число с нулем
    jl found_neg        ; Если нашли число < 0 (Jump if Less), идем к умножению
    inc bx              ; Иначе сдвигаем указатель на следующий байт
    loop find_neg       ; Повторяем, пока не найдем или не кончится массив (CX=0)

    ; Если цикл завершился и мы здесь — отрицательных чисел нет
    mov ah, 09h         
    mov dx, msg_none    ; Печатаем "No negative elements found!"
    int 21h             
    jmp exit            ; Уходим на выход

found_neg:
    ; В AL сейчас находится значение первого встреченного отрицательного элемента
    ; 3. Умножение на последний элемент
    ; Нам нужно найти адрес последней ячейки: Начало + Длина - 1
    mov si, array       ; Загружаем в SI адрес начала массива
    add si, [count]     ; Прибавляем 8 (SI теперь указывает ЗА массив)
    dec si              ; Вычитаем 1 (SI теперь указывает точно на 8-й элемент)
    
    mov dl, [si]        ; Загружаем значение последнего элемента массива в DL
    ; IMUL (Signed Multiply) — умножает AL на DL с учетом знаков.
    ; Результат сохраняется в регистр AX.
    imul dl             ; AX = AL * DL (первый отрицательный * последний)
    
    mov bx, ax          ; Сохраняем результат произведения в BX для последующего вывода

    ; 4. Вывод результата
    mov ah, 09h         ; Печать заголовка результата
    mov dx, msg_res
    int 21h
    
    mov ax, bx          ; Переносим результат обратно в AX (аргумент для процедуры)
    call print_num_ax   ; Вызываем процедуру, которая выведет AX как текстовое число

exit:
    mov ah, 09h         ; Печать сообщения о паузе
    mov dx, msg_pause
    int 21h
    mov ah, 08h         ; Ожидание нажатия любой клавиши
    int 21h
    mov ax, 4C00h       ; Завершение программы и возврат в DOS
    int 21h

;-- Процедура вывода числа в AX (разбивает число на цифры и печатает) --
print_num_ax:
    test ax, ax         ; Проверяем число в AX на знак
    jns .positive       ; Если число положительное (Jump Not Signed), идем дальше
    push ax             ; Если отрицательное, сохраняем число
    mov dl, '-'         ; Печатаем символ минуса
    mov ah, 02h
    int 21h
    pop ax              ; Достаем число
    neg ax              ; Делаем число положительным для алгоритма вывода
.positive:
    xor cx, cx          ; Обнуляем CX (будем считать количество цифр)
    mov bx, 10          ; Делитель для получения десятичных разрядов
.div_loop:
    xor dx, dx          ; Обнуляем DX перед делением (младшая часть AX, старшая DX)
    div bx              ; Делим AX на 10. Частное в AX, остаток в DX (это цифра)
    push dx             ; Сохраняем цифру в стек (они выходят в обратном порядке)
    inc cx              ; Считаем цифру
    test ax, ax         ; Проверяем, осталось ли что-то в AX
    jnz .div_loop       ; Если AX не 0, продолжаем делить
.print_loop:
    pop dx              ; Извлекаем цифру из стека (теперь в правильном порядке)
    add dl, '0'         ; Превращаем цифру (0-9) в ASCII символ ('0'-'9')
    mov ah, 02h         ; Печатаем символ через функцию DOS
    int 21h
    loop .print_loop    ; Повторяем для всех накопленных в стеке цифр
    ret                 ; Возвращаемся из процедуры
