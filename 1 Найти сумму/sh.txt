use16
org 100h

    jmp start

;-- Данные ----------------------------------------------------------
msg_input  db 'Enter 8 hex digits (0-F): ', '$'
msg_res    db 13, 10, 'Sum of elements < Ah is: ', '$'
msg_pause  db 13, 10, 'Press any key to exit...', '$'
array      db 8 dup(0)
count      dw 8
threshold  db 0Ah      ; Порог Ah (10)
;--------------------------------------------------------------------

start:
    ; 1. Ввод массива
    mov ah, 09h
    mov dx, msg_input
    int 21h

    mov cx, [count]     ; Цикл на 8 итераций
    mov bx, array
input_loop:
    mov ah, 01h         ; Ввод символа
    int 21h
    
    ; Преобразование ASCII ('0'-'F') в число (0-15)
    cmp al, '9'
    jbe .is_num
    and al, 11011111b   ; В верхний регистр
    sub al, 7
.is_num:
    sub al, '0'
    
    mov [bx], al        ; Сохраняем байт
    inc bx
    
    ; Вывод пробела
    mov ah, 02h
    mov dl, ' '
    int 21h
    loop input_loop

    ; 2. Подсчет суммы
    mov cx, [count]
    mov bx, array
    xor ax, ax          ; ОЧИЩАЕМ AX (сумма будет тут)
    xor dx, dx          ; ОЧИЩАЕМ DX для страховки

calc_sum:
    mov dl, [bx]        ; Берем число из массива в DL
    cmp dl, [threshold] ; Сравниваем с 10 (Ah)
    jae next_step       ; Если >= 10, пропускаем
    
    add al, dl          ; Прибавляем к сумме

next_step:
    inc bx
    loop calc_sum

    ; 3. Вывод результата
    push ax             ; Сохраняем полученную сумму
    mov ah, 09h
    mov dx, msg_res
    int 21h
    pop ax              ; Достаем сумму для печати

    call print_dec      ; Печатаем число в десятичном виде

    ; 4. Выход
    mov ah, 09h
    mov dx, msg_pause
    int 21h
    mov ah, 08h         ; Пауза
    int 21h
    mov ax, 4C00h       ; Завершение
    int 21h

;-- Процедура вывода десятичного числа (из AX) ----------------------
print_dec:
    push cx
    push dx
    push bx
    mov bx, 10          ; Делитель
    xor cx, cx          ; Счетчик цифр
.div_loop:
    xor dx, dx
    div bx              ; AX / 10, остаток в DX
    push dx             ; Сохраняем цифру в стек
    inc cx
    test ax, ax
    jnz .div_loop
.print_loop:
    pop dx              ; Берем цифру обратно
    add dl, '0'         ; В ASCII
    mov ah, 02h
    int 21h
    loop .print_loop
    pop bx
    pop dx
    pop cx
    ret


! Описание:
Goto: 154

! Вводи: 1 5 A B 2 F 3 4

! Как работает:

use16                   ; Указываем компилятору использовать 16-битный режим (DOS)
org 100h                ; Смещение 100h — стандарт для программ формата .COM

    jmp start           ; Прыгаем в начало кода, перескакивая через блок данных

;-- Блок данных в оперативной памяти --------------------------------
msg_input  db 'Enter 8 hex digits (0-F): ', '$'          ; Строка приглашения
msg_res    db 13, 10, 'Sum of elements < Ah is: ', '$'   ; Строка результата (13,10 - новая строка)
msg_pause  db 13, 10, 'Press any key to exit...', '$'    ; Строка паузы
array      db 8 dup(0)                                   ; Выделяем 8 байт под массив, заполняем нулями
count      dw 8                                          ; Слово (2 байта) со значением длины массива
threshold  db 0Ah                                        ; Наш порог для сравнения (10 в десятичной)

;-- Основной код ----------------------------------------------------
start:
    ; 1. Ввод массива с клавиатуры
    mov ah, 09h         ; Функция DOS 09h: вывод строки на экран
    mov dx, msg_input   ; Загружаем адрес строки в DX
    int 21h             ; Вызываем прерывание DOS

    mov cx, [count]     ; Загружаем 8 в счетчик CX для цикла LOOP
    mov bx, array       ; Записываем адрес начала массива в регистр BX

input_loop:
    mov ah, 01h         ; Функция DOS 01h: ввод символа с эхом
    int 21h             ; Символ попадает в регистр AL в виде ASCII-кода
    
    ; Конвертируем ASCII-символ ('0'-'F') в реальное число (0-15)
    cmp al, '9'         ; Проверяем: введена цифра или буква?
    jbe .is_num         ; Если AL <= '9', прыгаем на метку .is_num
    and al, 11011111b   ; Сбрасываем 5-й бит, чтобы сделать букву заглавной (a -> A)
    sub al, 7           ; Корректируем разрыв в таблице ASCII между цифрами и буквами
.is_num:
    sub al, '0'         ; Вычитаем 30h (код '0'), чтобы получить число
    
    mov [bx], al        ; Записываем полученное число из AL в память по адресу в BX
    inc bx              ; Сдвигаем указатель BX на следующий байт в массиве
    
    ; Вывод пробела после каждого ввода
    mov ah, 02h         ; Функция DOS 02h: вывод одного символа
    mov dl, ' '         ; Записываем символ пробела в DL
    int 21h             ; Выполняем вывод
    loop input_loop     ; Уменьшаем CX на 1. Если CX не 0, прыгаем в начало input_loop

    ; 2. Подсчет суммы элементов < Ah
    mov cx, [count]     ; Снова настраиваем цикл на 8 итераций
    mov bx, array       ; Снова ставим указатель BX на начало массива
    xor ax, ax          ; Обнуляем AX (эквивалентно mov ax, 0). Тут будет сумма.
    xor dx, dx          ; Обнуляем DX для использования DL как временного буфера

calc_sum:
    mov dl, [bx]        ; Копируем текущий байт из памяти (адрес в BX) в регистр DL
    cmp dl, [threshold] ; Сравниваем значение в DL с нашим порогом (10)
    jae next_step       ; Если DL >= 10 (Above or Equal), прыгаем к следующему элементу
    
    add al, dl          ; Если DL < 10, прибавляем значение к AL (накопление суммы)

next_step:
    inc bx              ; Переходим к следующему адресу в памяти
    loop calc_sum       ; Повторяем цикл, пока CX не станет равен 0

    ; 3. Вывод итоговой суммы
    push ax             ; Сохраняем результат суммы в стек, так как вызов DOS его испортит
    mov ah, 09h         ; Выводим строку "Sum of elements..."
    mov dx, msg_res
    int 21h
    pop ax              ; Достаем нашу сумму из стека обратно в AX

    call print_dec      ; Вызываем процедуру печати числа из AX в десятичном виде

    ; 4. Завершение работы
    mov ah, 09h         ; Выводим сообщение о паузе
    mov dx, msg_pause
    int 21h
    mov ah, 08h         ; Ждем нажатия любой клавиши (без эха на экран)
    int 21h
    mov ax, 4C00h       ; Функция DOS 4Ch: корректное завершение программы
    int 21h

;-- Процедура вывода числа из AX на экран --------------------------
print_dec:
    push cx             ; Сохраняем регистры в стек, чтобы не испортить их значения
    push dx
    push bx
    mov bx, 10          ; Делитель для получения десятичных разрядов
    xor cx, cx          ; Обнуляем счетчик цифр
.div_loop:
    xor dx, dx          ; Перед делением DX:AX / BX всегда обнуляем DX
    div bx              ; Делим AX на 10. Частное в AX, остаток в DX
    push dx             ; Остаток (последнюю цифру) кладем в стек
    inc cx              ; Считаем количество цифр
    test ax, ax         ; Проверяем, осталось ли что-то в AX?
    jnz .div_loop       ; Если AX не 0, продолжаем делить
.print_loop:
    pop dx              ; Забираем цифры из стека (в обратном порядке)
    add dl, '0'         ; Превращаем цифру обратно в ASCII-символ ('0'-'9')
    mov ah, 02h         ; Выводим символ на экран
    int 21h
    loop .print_loop    ; Печатаем все цифры из стека
    pop bx              ; Восстанавливаем регистры из стека
    pop dx
    pop cx
    ret                 ; Возврат из процедуры

