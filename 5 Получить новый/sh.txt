use16
org 100h

    jmp start

;-- Данные ----------------------------------------------------------
msg_input  db 'Enter 8 single digits (0-9):', 13, 10, '$'
msg_orig   db 13, 10, 'Original array: ', '$'
msg_res    db 13, 10, 'New array (elements / 2): ', '$'
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$'

count      dw 8
array_src  db 8 dup(0)    ; Исходный массив
array_dest db 8 dup(0)    ; Новый массив
;--------------------------------------------------------------------

start:
    ; 1. Ввод исходного массива
    mov ah, 09h
    mov dx, msg_input
    int 21h

    mov cx, [count]       ; Счётчик цикла
    mov bx, array_src
input_loop:
    mov ah, 01h           ; Ввод символа
    int 21h
    sub al, '0'           ; ASCII -> Число
    mov [bx], al          ; Сохраняем
    
    inc bx
    mov ah, 02h           ; Пробел
    mov dl, ' '
    int 21h
    loop input_loop

    ; 2. Копирование с делением на 2
    mov cx, [count]
    mov si, array_src     ; SI - откуда берем
    mov di, array_dest    ; DI - куда кладем

process_loop:
    mov al, [si]          ; Читаем элемент
    
    ; Деление на 2 через логический сдвиг вправо
    shr al, 1             ; AL = AL / 2
    
    mov [di], al          ; Сохраняем в новый массив
    inc si
    inc di
    loop process_loop

    ; 3. Вывод оригинального массива
    mov ah, 09h
    mov dx, msg_orig
    int 21h
    mov bx, array_src
    call print_array

    ; 4. Вывод нового массива
    mov ah, 09h
    mov dx, msg_res
    int 21h
    mov bx, array_dest
    call print_array

    ; 5. Пауза и выход
    mov ah, 09h
    mov dx, msg_pause
    int 21h
    mov ah, 08h           ; Ожидание клавиши
    int 21h
    mov ax, 4C00h         ; Завершение
    int 21h

;-- Подпрограмма вывода массива -------------------------------------
print_array:
    push cx
    mov cx, [count]
lp_print:
    mov al, [bx]
    add al, '0'           ; Число -> ASCII
    mov dl, al
    mov ah, 02h           ; Вывод символа
    int 21h
    mov dl, ' '
    int 21h
    inc bx
    loop lp_print
    pop cx
    ret


! Описание:
Goto: 170, 178

! Как работает:

use16                   ; Использовать 16-битный режим процессора (стандарт для DOS)
org 100h                ; Установить точку входа на смещение 100h (структура .COM файла)

    jmp start           ; Перепрыгнуть блок данных, чтобы процессор не пытался их выполнить

;-- Блок данных в оперативной памяти --------------------------------
msg_input  db 'Enter 8 single digits (0-9):', 13, 10, '$' ; Строка приглашения
msg_orig   db 13, 10, 'Original array: ', '$'             ; Текст для вывода оригинала
msg_res    db 13, 10, 'New array (elements / 2): ', '$'  ; Текст для вывода результата
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$' ; Текст паузы

count      dw 8         ; Переменная (слово), хранящая размер массива (8)
array_src  db 8 dup(0)  ; Выделяем 8 байт под исходный массив, заполняем нулями
array_dest db 8 dup(0)  ; Выделяем 8 байт под новый массив (результат)
;--------------------------------------------------------------------

start:
    ; 1. Ввод исходного массива
    mov ah, 09h         ; Функция DOS 09h: печать строки из DX на экран
    mov dx, msg_input   ; Загружаем адрес начала строки msg_input в DX
    int 21h             ; Системный вызов прерывания DOS

    mov cx, [count]     ; Устанавливаем счетчик цикла CX равным 8
    mov bx, array_src   ; Загружаем в BX адрес начала первого массива
input_loop:
    mov ah, 01h         ; Функция DOS 01h: ввод символа с клавиатуры с эхом
    int 21h             ; ASCII-код символа попадает в регистр AL
    sub al, '0'         ; Конвертируем код (например, 31h для '1') в число (1)
    mov [bx], al        ; Копируем число из AL в ячейку памяти по адресу в BX
    
    inc bx              ; Увеличиваем адрес в BX на 1 (переход к следующему байту)
    mov ah, 02h         ; Функция DOS 02h: вывод одного символа из DL
    mov dl, ' '         ; Кладем символ пробела в DL
    int 21h             ; Печатаем пробел после каждой введенной цифры
    loop input_loop     ; Уменьшаем CX на 1. Если CX > 0, идем на начало цикла

    ; 2. Копирование с делением на 2
    mov cx, [count]     ; Снова устанавливаем 8 повторений в CX
    mov si, array_src   ; SI указывает на начало ИСТОЧНИКА (Source Index)
    mov di, array_dest  ; DI указывает на начало ПРИЕМНИКА (Destination Index)

process_loop:
    mov al, [si]        ; Копируем байт из исходного массива (адрес в SI) в AL
    
    ; Деление на 2 через логический сдвиг вправо
    shr al, 1           ; Сдвигаем биты в AL вправо на 1 позицию. Это эквивалентно AL / 2
    
    mov [di], al        ; Копируем измененное значение из AL в новый массив (адрес в DI)
    inc si              ; Сдвигаем указатель источника вперед на 1 байт
    inc di              ; Сдвигаем указатель приемника вперед на 1 байт
    loop process_loop   ; Повторяем цикл, пока не обработаем все 8 элементов

    ; 3. Вывод оригинального массива
    mov ah, 09h         ; Вывод строки msg_orig
    mov dx, msg_orig
    int 21h
    mov bx, array_src   ; Подготавливаем BX для подпрограммы (указываем на старый массив)
    call print_array    ; Вызываем процедуру печати

    ; 4. Вывод нового массива
    mov ah, 09h         ; Вывод строки msg_res
    mov dx, msg_res
    int 21h
    mov bx, array_dest  ; Подготавливаем BX (указываем на новый массив с результатами)
    call print_array    ; Вызываем процедуру печати

    ; 5. Пауза и выход
    mov ah, 09h         ; Печать текста "Press any key..."
    mov dx, msg_pause
    int 21h
    mov ah, 08h         ; Функция DOS 08h: ожидание нажатия клавиши без вывода на экран
    int 21h             ; Программа замирает, пока пользователь не нажмет кнопку
    mov ax, 4C00h       ; Функция DOS 4Ch: завершение программы и возврат кода 00
    int 21h             ; Выход в систему

;-- Подпрограмма вывода массива (печатает элементы по адресу из BX) --
print_array:
    push cx             ; Сохраняем CX в стек, чтобы не испортить внешний счетчик
    mov cx, [count]     ; Устанавливаем 8 повторений для печати
lp_print:
    mov al, [bx]        ; Читаем число из памяти (адрес в BX) в AL
    add al, '0'         ; Конвертируем число (1) обратно в символ ASCII ('1')
    mov dl, al          ; Кладём символ в DL для функции вывода
    mov ah, 02h         ; Функция вывода одного символа
    int 21h             ; Печатаем цифру
    mov dl, ' '         ; Готовим пробел
    int 21h             ; Печатаем пробел
    inc bx              ; Переходим к следующему адресу в массиве
    loop lp_print       ; Цикл, пока не напечатаем 8 цифр
    pop cx              ; Достаем старое значение CX из стека
    ret                 ; Возвращаемся в основную программу
