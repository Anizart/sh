use16
org 100h

    jmp start

;-- Данные ----------------------------------------------------------
msg_input  db 'Enter 8 single digits (0-9):', 13, 10, '$'
msg_orig   db 13, 10, 'Original array: ', '$'
msg_res    db 13, 10, 'Result (elements * 2): ', '$'
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$'

array      db 8 dup(0)
count      dw 8
;--------------------------------------------------------------------

start:
    ; 1. Ввод исходного массива
    mov ah, 09h
    mov dx, msg_input
    int 21h

    mov cx, [count]     ; Счётчик цикла
    mov bx, array       ; Указатель на начало массива
input_loop:
    mov ah, 01h         ; Ввод символа
    int 21h
    sub al, '0'         ; ASCII -> Число
    mov [bx], al        ; Сохраняем в память
    
    inc bx
    mov ah, 02h         ; Вывод пробела для удобства
    mov dl, ' '
    int 21h
    loop input_loop

    ; 2. Вывод оригинального массива
    mov ah, 09h
    mov dx, msg_orig
    int 21h
    call print_array

    ; 3. Увеличение каждого элемента в 2 раза
    mov cx, [count]
    mov bx, array
multiply_loop:
    mov al, [bx]        ; Берем число из памяти
    shl al, 1           ; Умножаем на 2 (сдвиг влево)
    mov [bx], al        ; Записываем обратно
    inc bx
    loop multiply_loop  ; Повторяем для всех элементов

    ; 4. Вывод измененного массива
    mov ah, 09h
    mov dx, msg_res
    int 21h
    call print_array

    ; 5. Пауза и выход
    mov ah, 09h
    mov dx, msg_pause
    int 21h
    mov ah, 08h         ; Ожидание нажатия клавиши
    int 21h
    mov ax, 4C00h       ; Завершение программы
    int 21h

;-- Подпрограмма вывода массива -------------------------------------
print_array:
    push cx
    push bx
    mov cx, [count]
    mov bx, array
.lp:
    mov al, [bx]
    
    ; Обработка вывода двузначных чисел (так как 9*2=18)
    xor ah, ah          ; Очищаем AH
    mov dl, 10
    div dl              ; Делим AL на 10. AH = остаток, AL = частное
    
    mov dx, ax          ; Сохраняем результат деления
    test dl, dl         ; Проверяем, есть ли десятки
    jz .single_digit
    
    push dx
    mov dl, al          ; Выводим первую цифру (десятки)
    add dl, '0'
    mov ah, 02h
    int 21h
    pop dx

.single_digit:
    mov dl, dh          ; Выводим вторую цифру (единицы)
    add dl, '0'
    mov ah, 02h
    int 21h
    
    mov dl, ' '         ; Пробел
    int 21h
    inc bx
    loop .lp
    pop bx
    pop cx
    ret


! Описание:
Goto: 17F

! Вводи: 1 3 5 2 4 0 9 7

! Как работает:

use16                   ; Использовать 16-битный режим (стандарт для DOS)
org 100h                ; Начало программы с адреса 100h (структура .COM файла)

    jmp start           ; Прыжок на метку start, чтобы пропустить блок данных

;-- Данные в оперативной памяти -------------------------------------
msg_input  db 'Enter 8 single digits (0-9):', 13, 10, '$' ; Сообщение-приглашение
msg_orig   db 13, 10, 'Original array: ', '$'             ; Текст перед выводом оригинала
msg_res    db 13, 10, 'Result (elements * 2): ', '$'      ; Текст перед выводом результата
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$' ; Текст паузы

array      db 8 dup(0)  ; Выделение 8 байт под массив, заполненных нулями
count      dw 8         ; Переменная, хранящая размер массива (8)
;--------------------------------------------------------------------

start:
    ; 1. Ввод исходного массива
    mov ah, 09h         ; Функция DOS 09h: вывод строки на экран
    mov dx, msg_input   ; Загрузка адреса строки в DX
    int 21h             ; Вызов прерывания (печать приглашения)

    mov cx, [count]     ; Загружаем 8 в счетчик CX для цикла ввода
    mov bx, array       ; BX — указатель, ставим его на начало массива
input_loop:
    mov ah, 01h         ; Функция DOS 01h: ввод символа с клавиатуры
    int 21h             ; Код символа попадает в AL
    sub al, '0'         ; Превращаем ASCII-код (например, 35h) в число (5)
    mov [bx], al        ; Сохраняем полученное число в память по адресу в BX
    
    inc bx              ; Сдвигаем указатель BX на 1 байт вперед
    mov ah, 02h         ; Функция DOS 02h: вывод одного символа
    mov dl, ' '         ; Кладем пробел в DL
    int 21h             ; Печать пробела (визуальное разделение ввода)
    loop input_loop     ; Уменьшаем CX. Если CX > 0, идем на начало input_loop

    ; 2. Вывод оригинального массива
    mov ah, 09h         ; Вывод заголовка "Original array"
    mov dx, msg_orig
    int 21h
    call print_array    ; Вызов подпрограммы печати всех элементов

    ; 3. Увеличение каждого элемента в 2 раза
    mov cx, [count]     ; Настраиваем цикл на 8 повторений
    mov bx, array       ; Снова ставим указатель BX на начало массива
multiply_loop:
    mov al, [bx]        ; Читаем число из памяти в регистр AL
    
    ; Логический сдвиг влево на 1 бит: все биты смещаются влево, 
    ; что математически равносильно умножению на 2.
    
    shl al, 1           ; AL = AL * 2
    
    mov [bx], al        ; Записываем удвоенное значение обратно в память
    inc bx              ; Сдвигаем указатель на следующий элемент
    loop multiply_loop  ; Повторяем для всех 8 элементов

    ; 4. Вывод измененного массива
    mov ah, 09h         ; Вывод заголовка "Result..."
    mov dx, msg_res
    int 21h
    call print_array    ; Вызов подпрограммы печати

    ; 5. Пауза и выход
    mov ah, 09h         ; Вывод сообщения о паузе
    mov dx, msg_pause
    int 21h
    mov ah, 08h         ; Функция DOS 08h: чтение клавиши без эха (пауза)
    int 21h
    mov ax, 4C00h       ; Функция DOS 4Ch: завершение программы
    int 21h

;-- Подпрограмма вывода массива -------------------------------------
print_array:
    push cx             ; Сохраняем CX и BX в стек, чтобы не испортить их
    push bx
    mov cx, [count]     ; Цикл на 8 элементов
    mov bx, array
.lp:
    mov al, [bx]        ; Берем текущее число из памяти
    
    ; Так как результат может быть > 9 (например, 9*2=18),
    ; число нужно разбить на десятки и единицы для вывода.
    xor ah, ah          ; Обнуляем AH (готовим AX для деления)
    mov dl, 10          ; Будем делить на 10
    div dl              ; AX / 10. Частное (десятки) в AL, Остаток (единицы) в AH
    
    mov dx, ax          ; Сохраняем результат: DL=частное, DH=остаток
    test dl, dl         ; Проверяем, есть ли десятки (частное равно 0?)
    jz .single_digit    ; Если десятков нет, прыгаем сразу на вывод единиц
    
    push dx             ; Сохраняем DX (результат деления)
    mov dl, al          ; Перемещаем десятки в DL
    add dl, '0'         ; Превращаем число в ASCII-символ
    mov ah, 02h         ; Функция вывода символа
    int 21h             ; Печать десятков
    pop dx              ; Восстанавливаем DX

.single_digit:
    mov dl, dh          ; Перемещаем единицы (остаток) в DL
    add dl, '0'         ; Превращаем в ASCII-символ
    mov ah, 02h         ; Функция вывода
    int 21h             ; Печать единиц
    
    mov dl, ' '         ; Печать пробела после числа
    int 21h
    inc bx              ; Переход к следующему байту массива
    loop .lp            ; Крутим цикл lp
    pop bx              ; Восстанавливаем регистры из стека
    pop cx
    ret                 ; Возвращаемся в основную программу
