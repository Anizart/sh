use16
org 100h

    jmp start

;-- Данные ----------------------------------------------------------
msg_input  db 'Enter 8 single digits (use - for negative):', 13, 10, '$'
msg_orig   db 13, 10, 'Original array: ', '$'
msg_res    db 13, 10, 'Result (max element replaced with 0): ', '$'
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$'

array      db 8 dup(0)
count      dw 8
;--------------------------------------------------------------------

start:
    ; 1. Ввод исходного массива
    mov ah, 09h
    mov dx, msg_input
    int 21h

    mov cx, [count]
    mov bx, array
input_loop:
    mov ah, 01h
    int 21h
    cmp al, '-'         ; Обработка отрицательных чисел
    jne .pos
    int 21h
    sub al, '0'
    neg al
    jmp .save
.pos:
    sub al, '0'
.save:
    mov [bx], al        ; Сохраняем в память
    inc bx
    mov ah, 02h         ; Пробел
    mov dl, ' '
    int 21h
    loop input_loop

    ; 2. Вывод оригинального массива
    mov ah, 09h
    mov dx, msg_orig
    int 21h
    call print_array

    ; 3. Поиск максимального элемента
    mov cx, [count]
    mov bx, array
    mov al, [bx]        ; Пусть первый элемент — максимум
    mov di, bx          ; DI будет хранить адрес максимального элемента

find_max:
    mov dl, [bx]        ; Текущий элемент
    cmp dl, al          ; Сравниваем текущий с максимальным
    jg .new_max         ; Если текущий больше (Jump if Greater)
    jmp .next

.new_max:
    mov al, dl          ; Обновляем значение максимума
    mov di, bx          ; Запоминаем адрес нового максимума

.next:
    inc bx
    loop find_max

    ; 4. Запись 0 в позицию максимального элемента
    mov byte [di], 0    ; По адресу максимума пишем 0

    ; 5. Вывод итогового массива
    mov ah, 09h
    mov dx, msg_res
    int 21h
    call print_array

    ; 6. Выход
    mov ah, 09h
    mov dx, msg_pause
    int 21h
    mov ah, 08h         ; Пауза
    int 21h
    mov ax, 4C00h       ; Завершение
    int 21h

;-- Подпрограмма вывода массива -------------------------------------
print_array:
    push cx
    push bx
    mov cx, [count]
    mov bx, array
.lp:
    mov al, [bx]
    cmp al, 0
    jge .p
    push ax
    mov dl, '-'
    mov ah, 02h
    int 21h
    pop ax
    neg al
.p:
    add al, '0'         ; Число -> ASCII
    mov dl, al
    mov ah, 02h
    int 21h
    mov dl, ' '
    int 21h
    inc bx
    loop .lp
    pop bx
    pop cx
    ret


! Описание:
Goto: 18A

! Вводи: 3 7 1 -5 9 4 2 6

! Как работает:

use16                   ; Использовать 16-битный режим процессора (DOS)
org 100h                ; Начало программы со смещения 100h (стандарт .COM)

    jmp start           ; Прыжок на метку start, чтобы пропустить блок данных

;-- Данные в оперативной памяти -------------------------------------
msg_input  db 'Enter 8 single digits (use - for negative):', 13, 10, '$' ; Приглашение
msg_orig   db 13, 10, 'Original array: ', '$'             ; Заголовок для оригинала
msg_res    db 13, 10, 'Result (max element replaced with 0): ', '$' ; Заголовок для результата
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$' ; Текст паузы

array      db 8 dup(0)  ; Выделяем 8 байт под массив (все нули)
count      dw 8         ; Размер массива (число элементов)
;--------------------------------------------------------------------

start:
    ; 1. Ввод исходного массива
    mov ah, 09h         ; Функция DOS 09h: вывод строки на экран
    mov dx, msg_input   ; Загружаем адрес сообщения в DX
    int 21h             ; Печать приглашения

    mov cx, [count]     ; Устанавливаем счетчик цикла CX = 8
    mov bx, array       ; BX указывает на начало массива в памяти
input_loop:
    mov ah, 01h         ; Функция DOS 01h: ввод символа с эхом (в AL)
    int 21h             ; Ждем нажатия клавиши
    cmp al, '-'         ; Проверяем, ввел ли пользователь минус
    jne .pos            ; Если не минус, прыгаем на метку .pos
    int 21h             ; Если минус, вводим саму цифру в AL
    sub al, '0'         ; ASCII-код цифры -> число (например, '5' -> 5)
    neg al              ; Меняем знак числа на минус (5 -> -5)
    jmp .save           ; Прыгаем к сохранению
.pos:
    sub al, '0'         ; Конвертируем положительную цифру из ASCII в число
.save:
    mov [bx], al        ; Записываем число из AL в память по адресу в BX
    inc bx              ; Сдвигаем указатель BX на 1 байт (к следующей ячейке)
    mov ah, 02h         ; Функция DOS 02h: печать одного символа
    mov dl, ' '         ; Печатаем пробел после каждой цифры
    int 21h             
    loop input_loop     ; Уменьшаем CX, если CX > 0, идем на начало input_loop

    ; 2. Вывод оригинального массива
    mov ah, 09h         ; Печать сообщения "Original array"
    mov dx, msg_orig
    int 21h
    call print_array    ; Вызов подпрограммы печати массива

    ; 3. Поиск максимального элемента
    mov cx, [count]     ; Снова настраиваем цикл на 8 итераций
    mov bx, array       ; BX ставим на начало массива
    mov al, [bx]        ; Загружаем первый элемент в AL (текущий максимум)
    mov di, bx          ; В DI запоминаем АДРЕС этого первого элемента

find_max:
    mov dl, [bx]        ; Читаем текущий элемент из памяти в DL
    cmp dl, al          ; Сравниваем текущий (DL) с максимумом (AL)
    jg .new_max         ; Если текущий больше (Jump if Greater), прыгаем на .new_max
    jmp .next           ; Иначе идем к следующему элементу

.new_max:
    mov al, dl          ; Обновляем значение максимума в AL
    mov di, bx          ; ОБНОВЛЯЕМ АДРЕС максимума в DI (самая важная строка!)

.next:
    inc bx              ; Сдвигаем указатель BX на 1 байт вперед
    loop find_max       ; Повторяем цикл, пока CX не станет 0

    ; 4. Запись 0 в позицию максимального элемента
    ; Теперь DI хранит точный адрес того байта, который был самым большим
    mov byte [di], 0    ; Записываем число 0 по адресу, хранящемуся в DI

    ; 5. Вывод итогового массива
    mov ah, 09h         ; Печать сообщения "Result..."
    mov dx, msg_res
    int 21h
    call print_array    ; Печать массива после замены максимума на 0

    ; 6. Выход
    mov ah, 09h         ; Печать сообщения о паузе
    mov dx, msg_pause
    int 21h
    mov ah, 08h         ; Функция ожидания нажатия клавиши
    int 21h
    mov ax, 4C00h       ; Корректное завершение программы
    int 21h

;-- Подпрограмма вывода массива -------------------------------------
print_array:
    push cx             ; Сохраняем CX в стек (защита данных)
    push bx             ; Сохраняем BX в стек
    mov cx, [count]     ; Счетчик на 8 элементов
    mov bx, array       ; Печатаем с начала массива
.lp:
    mov al, [bx]        ; Берем число из памяти
    cmp al, 0           ; Проверяем знак
    jge .p              ; Если >= 0, идем к .p
    push ax             ; Если < 0, сохраняем число
    mov dl, '-'         ; Печатаем знак минус
    mov ah, 02h
    int 21h
    pop ax              ; Достаем число
    neg al              ; Делаем положительным для корректной печати цифры
.p:
    add al, '0'         ; Число -> ASCII
    mov dl, al          ; Кладём в DL
    mov ah, 02h         ; Печать символа
    int 21h
    mov dl, ' '         ; Печать пробела
    int 21h
    inc bx              ; Переход к следующему байту
    loop .lp            ; Крутим цикл
    pop bx              ; Восстанавливаем BX из стека
    pop cx              ; Восстанавливаем CX из стека
    ret                 ; Возвращаемся в точку вызова
