use16
org 100h

    jmp start

;-- Данные ----------------------------------------------------------
msg_input  db 'Enter 8 digits (use - for negative):', 13, 10, '$'
msg_orig   db 13, 10, 'Original array: ', '$'
msg_res    db 13, 10, 'Count of negative elements: ', '$'
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$'

array      db 8 dup(0)
count      dw 8
;--------------------------------------------------------------------

start:
    ; 1. Ввод исходного массива
    mov ah, 09h
    mov dx, msg_input
    int 21h

    mov cx, [count]
    mov bx, array
input_loop:
    mov ah, 01h
    int 21h
    cmp al, '-'         ; Обработка знака минус
    jne .pos
    int 21h             ; Читаем саму цифру
    sub al, '0'
    neg al
    jmp .save
.pos:
    sub al, '0'
.save:
    mov [bx], al
    inc bx
    mov ah, 02h         ; Пробел
    mov dl, ' '
    int 21h
    loop input_loop

    ; 2. Вывод оригинального массива (для визуальной проверки)
    mov ah, 09h
    mov dx, msg_orig
    int 21h
    call print_array

    ; 3. Подсчет отрицательных элементов
    mov cx, [count]
    mov bx, array
    xor si, si          ; SI будет счетчиком (обнуляем его)

count_loop:
    cmp byte [bx], 0    ; Сравниваем текущий элемент с нулем
    jge .not_negative   ; Если >= 0, переходим к следующему
    
    inc si              ; Если меньше 0, увеличиваем наш счетчик на 1
    
.not_negative:
    inc bx              ; Переход к следующему элементу массива
    loop count_loop

    ; 4. Вывод результата
    mov ah, 09h
    mov dx, msg_res
    int 21h

    mov ax, si          ; Помещаем результат в AX для вывода
    add al, '0'         ; Преобразуем число в символ ASCII
    mov dl, al
    mov ah, 02h
    int 21h

    ; 5. Выход
    mov ah, 09h
    mov dx, msg_pause
    int 21h
    mov ah, 08h
    int 21h
    mov ax, 4C00h
    int 21h

;-- Подпрограмма вывода массива -------------------------------------
print_array:
    push cx
    push bx
    mov cx, [count]
    mov bx, array
.lp:
    mov al, [bx]
    cmp al, 0
    jge .p
    push ax
    mov dl, '-'
    mov ah, 02h
    int 21h
    pop ax
    neg al
.p:
    add al, '0'
    mov dl, al
    mov ah, 02h
    int 21h
    mov dl, ' '
    int 21h
    inc bx
    loop .lp
    pop bx
    pop cx
    ret


! Описание:
Goto: 179

! Вводи: -3 5 0 -1 -8 4 2 -6

! Как работает:

use16                   ; Использовать 16-битный режим (стандарт для DOS)
org 100h                ; Начальный адрес программы (структура .COM)

    jmp start           ; Перепрыгнуть через данные, чтобы сразу начать выполнение кода

;-- Данные в оперативной памяти -------------------------------------
msg_input  db 'Enter 8 digits (use - for negative):', 13, 10, '$' ; Приглашение к вводу
msg_orig   db 13, 10, 'Original array: ', '$'        ; Текст перед выводом массива
msg_res    db 13, 10, 'Count of negative elements: ', '$' ; Текст перед результатом
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$' ; Текст паузы

array      db 8 dup(0)  ; Выделение 8 байт (ячеек) в памяти под массив
count      dw 8         ; Переменная, хранящая размер массива (8)
;--------------------------------------------------------------------

start:
    ; 1. Ввод исходного массива
    mov ah, 09h         ; Функция DOS 09h: вывод строки на экран
    mov dx, msg_input   ; DX указывает на адрес строки приглашения
    int 21h             ; Системный вызов прерывания

    mov cx, [count]     ; Записываем 8 в CX (счетчик итераций цикла ввода)
    mov bx, array       ; BX — указатель на текущую ячейку массива (начинаем с 0)
input_loop:
    mov ah, 01h         ; Функция DOS 01h: считать символ с клавиатуры в AL
    int 21h             ; Программа ждет нажатия клавиши
    cmp al, '-'         ; Сравниваем введенный символ со знаком "минус"
    jne .pos            ; Если ввели НЕ минус (Jump Not Equal), идем к обработке цифры
    int 21h             ; Если был минус, считываем следующий символ (саму цифру)
    sub al, '0'         ; Переводим символ в число (ASCII '5' (53) -> число 5)
    neg al              ; Меняем знак числа в AL (из 5 делаем -5)
    jmp .save           ; Переход к сохранению, минуя блок положительного числа
.pos:
    sub al, '0'         ; Конвертируем символ цифры в число
.save:
    mov [bx], al        ; Записываем готовое число из AL в память по адресу в BX
    inc bx              ; Сдвигаем указатель BX на 1 байт вперед (к следующей ячейке)
    mov ah, 02h         ; Функция DOS 02h: вывод одного символа
    mov dl, ' '         ; Выводим пробел для красоты ввода
    int 21h             
    loop input_loop     ; Уменьшаем CX на 1. Если CX > 0, прыгаем в начало цикла

    ; 2. Вывод оригинального массива
    mov ah, 09h         
    mov dx, msg_orig    
    int 21h             
    call print_array    ; Вызов подпрограммы для печати содержимого массива

    ; 3. Подсчет отрицательных элементов
    mov cx, [count]     ; Снова настраиваем цикл на 8 повторений
    mov bx, array       ; Устанавливаем BX на начало массива
    xor si, si          ; Обнуляем регистр SI. Он будет нашим счетчиком (Count = 0)

count_loop:
    ; Команда CMP сравнивает число в памяти с нулем, выставляя флаги процессора
    cmp byte [bx], 0    ; Сравниваем текущий байт массива с нулем
    
    ; JGE (Jump if Greater or Equal) — переход, если число Больше или Равно 0.
    ; Нам нужны только отрицательные (< 0), поэтому мы "перепрыгиваем" инкремент.
    jge .not_negative   ; Если число 0 или положительное, идем к .not_negative
    
    ; Если мы здесь, значит число меньше нуля.
    inc si              ; Увеличиваем наш счетчик (SI = SI + 1)
    
.not_negative:
    inc bx              ; Сдвигаем указатель BX к следующему байту массива
    loop count_loop     ; Повторяем для всех 8 элементов

    ; 4. Вывод результата
    mov ah, 09h         
    mov dx, msg_res     
    int 21h             

    mov ax, si          ; Переносим итоговое количество (из SI) в AX для работы
    add al, '0'         ; Превращаем число в символ (например, 3 -> '3' или 51 ASCII)
    mov dl, al          ; DL — аргумент для вывода символа
    mov ah, 02h         ; Функция вывода символа
    int 21h             ; Печать цифры-результата на экран

    ; 5. Выход
    mov ah, 09h         ; Печать текста паузы
    mov dx, msg_pause
    int 21h
    mov ah, 08h         ; Ожидание нажатия клавиши (пауза)
    int 21h
    mov ax, 4C00h       ; Завершение программы и выход в DOS
    int 21h

;-- Подпрограмма вывода массива (для визуализации) ------------------
print_array:
    push cx             ; Сохраняем значения регистров в стек, чтобы не сломать их
    push bx
    mov cx, [count]     
    mov bx, array       
.lp:
    mov al, [bx]        ; Читаем байт из массива
    cmp al, 0           ; Проверка знака для вывода
    jge .p              
    push ax             ; Если число отрицательное, печатаем '-'
    mov dl, '-'
    mov ah, 02h
    int 21h
    pop ax
    neg al              ; Превращаем в положительное для вывода цифры
.p:
    add al, '0'         ; Число -> ASCII
    mov dl, al
    mov ah, 02h
    int 21h
    mov dl, ' '         ; Вывод пробела
    int 21h
    inc bx              
    loop .lp            ; Крутим цикл
    pop bx              ; Возвращаем значения регистров из стека
    pop cx
    ret                 ; Возврат в основную программу
