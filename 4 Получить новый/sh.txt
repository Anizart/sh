use16
org 100h

    jmp start

;-- Данные ----------------------------------------------------------
msg_input  db 'Enter 8 single digits:', 13, 10, '$'
msg_orig   db 13, 10, 'Original array: ', '$'
msg_rev    db 13, 10, 'Reversed array: ', '$'
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$'

count      dw 8
array_src  db 8 dup(0)    ; Исходный массив
array_dest db 8 dup(0)    ; Новый массив для результата
;--------------------------------------------------------------------

start:
    ; 1. Ввод исходного массива
    mov ah, 09h
    mov dx, msg_input
    int 21h

    mov cx, [count]       ; Счётчик цикла
    mov bx, array_src     ; BX указывает на начало первого массива
input_loop:
    mov ah, 01h           ; Функция DOS - ввод символа
    int 21h
    sub al, '0'           ; Преобразование ASCII в число
    mov [bx], al          ; Сохранение в память
    
    inc bx                ; Следующий адрес
    
    mov ah, 02h           ; Вывод пробела
    mov dl, ' '
    int 21h
    loop input_loop       ; Цикл ввода

    ; 2. Копирование в обратном порядке
    mov cx, [count]
    mov si, array_src     ; SI указывает на начало исходного массива
    mov di, array_dest
    add di, [count]
    dec di                ; DI указывает на ПОСЛЕДНИЙ элемент нового массива

reverse_copy:
    mov al, [si]          ; Берем элемент из начала
    mov [di], al          ; Кладем в конец нового массива
    inc si                ; SI двигается вперед
    dec di                ; DI двигается назад
    loop reverse_copy     ; Повторяем для всех элементов

    ; 3. Вывод оригинального массива
    mov ah, 09h
    mov dx, msg_orig
    int 21h
    mov bx, array_src
    call print_array

    ; 4. Вывод развернутого массива
    mov ah, 09h
    mov dx, msg_rev
    int 21h
    mov bx, array_dest    ; Теперь выводим новый массив
    call print_array

    ; 5. Пауза и выход
    mov ah, 09h
    mov dx, msg_pause
    int 21h
    mov ah, 08h           ; Ожидание нажатия клавиши
    int 21h
    mov ax, 4C00h         ; Завершение
    int 21h

;-- Подпрограмма вывода массива -------------------------------------
print_array:
    push cx               ; Сохраняем CX в стек
    mov cx, [count]
lp_print:
    mov al, [bx]
    add al, '0'           ; Число -> ASCII
    mov dl, al
    mov ah, 02h           ; Вывод символа
    int 21h
    
    mov dl, ' '           ; Пробел
    int 21h
    inc bx
    loop lp_print
    pop cx                ; Восстанавливаем CX
    ret


! Описание:
Goto: 160, 168

! Как работает:

use16                   ; Использовать 16-битный режим (DOS)
org 100h                ; Смещение 100h — стандарт для программ .COM в памяти

    jmp start           ; Безусловный прыжок на метку start, чтобы пропустить блок данных

;-- Блок данных в оперативной памяти --------------------------------
msg_input  db 'Enter 8 single digits:', 13, 10, '$' ; Текст приглашения
msg_orig   db 13, 10, 'Original array: ', '$'        ; Текст перед выводом оригинала
msg_rev    db 13, 10, 'Reversed array: ', '$'        ; Текст перед выводом результата
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$' ; Текст паузы

count      dw 8         ; Слово (2 байта), размер массива
array_src  db 8 dup(0)  ; Выделяем 8 байт памяти под исходный массив
array_dest db 8 dup(0)  ; Выделяем 8 байт памяти под массив-результат
;--------------------------------------------------------------------

start:
    ; 1. Ввод исходного массива
    mov ah, 09h         ; Функция DOS 09h: вывод строки в DX на экран
    mov dx, msg_input   ; Записываем адрес строки приглашения в DX
    int 21h             ; Вызываем прерывание DOS (печать текста)

    mov cx, [count]     ; Загружаем число 8 в счетчик CX для цикла LOOP
    mov bx, array_src   ; Загружаем адрес начала первого массива в BX
input_loop:
    mov ah, 01h         ; Функция DOS 01h: чтение символа с клавиатуры
    int 21h             ; Символ (ASCII-код) попадает в регистр AL
    sub al, '0'         ; Переводим код символа (например, 31h) в число (1)
    mov [bx], al        ; Записываем полученное число в память по адресу в BX
    
    inc bx              ; Сдвигаем указатель BX на 1 байт вперед (к следующей ячейке)
    
    mov ah, 02h         ; Функция DOS 02h: вывод одного символа из DL
    mov dl, ' '         ; Кладем в DL символ пробела
    int 21h             ; Печатаем пробел в консоли
    loop input_loop     ; Уменьшаем CX. Если CX > 0, прыгаем в начало input_loop

    ; 2. Копирование в обратном порядке
    mov cx, [count]     ; Снова устанавливаем 8 повторений в CX
    mov si, array_src   ; SI указывает на НАЧАЛО исходного массива
    mov di, array_dest  ; DI указывает на НАЧАЛО целевого массива
    add di, [count]     ; Прибавляем к адресу 8...
    dec di              ; ...и вычитаем 1. Теперь DI указывает на ПОСЛЕДНИЙ байт целевого массива.

reverse_copy:
    mov al, [si]        ; Читаем байт из исходного массива (с начала)
    mov [di], al        ; Пишем этот байт в целевой массив (в конец)
    inc si              ; Указатель SI двигается ВПЕРЕД (+1)
    dec di              ; Указатель DI двигается НАЗАД (-1)
    loop reverse_copy   ; Повторяем, пока все 8 элементов не будут скопированы

    ; 3. Вывод оригинального массива
    mov ah, 09h         ; Вывод заголовка для оригинала
    mov dx, msg_orig
    int 21h
    mov bx, array_src   ; BX указывает на массив, который будет печатать print_array
    call print_array    ; Вызываем процедуру печати

    ; 4. Вывод развернутого массива
    mov ah, 09h         ; Вывод заголовка для результата
    mov dx, msg_rev
    int 21h
    mov bx, array_dest  ; Теперь BX указывает на новый развернутый массив
    call print_array    ; Вызываем ту же процедуру печати для него

    ; 5. Пауза и выход
    mov ah, 09h         ; Вывод строки паузы
    mov dx, msg_pause
    int 21h
    mov ah, 08h         ; Функция DOS 08h: ждать нажатия клавиши
    int 21h
    mov ax, 4C00h       ; Функция DOS 4Ch: корректно завершить процесс
    int 21h

;-- Подпрограмма вывода массива -------------------------------------
print_array:
    push cx             ; Сохраняем CX в стек, так как внутри процедуры он меняется
    mov cx, [count]     ; Загружаем 8 в CX для цикла печати
lp_print:
    mov al, [bx]        ; Читаем число из памяти по адресу BX
    add al, '0'         ; Превращаем число (1) обратно в символ ASCII ('1')
    mov dl, al          ; Кладём в DL для вывода через DOS
    mov ah, 02h         ; Функция вывода символа
    int 21h             ; Печать цифры
    
    mov dl, ' '         ; Печать пробела после цифры
    int 21h
    inc bx              ; Переход к следующему байту массива
    loop lp_print       ; Повторяем для всех элементов
    pop cx              ; Достаем старое значение CX из стека
    ret                 ; Возвращаемся в точку вызова программы
