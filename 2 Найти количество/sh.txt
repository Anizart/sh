use16
org 100h

    jmp start

;-- Данные ----------------------------------------------------------
msg_input  db 'Enter 8 hex values (00-FF, e.g. 05 12 A0):', 13, 10, '$'
msg_res    db 13, 10, 'Count of elements > 11h: ', '$'
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$'

array      db 8 dup(0)
count      dw 8
threshold  db 11h      ; Наш порог 11h (17 в десятичной)
;--------------------------------------------------------------------

start:
    ; 1. Ввод исходного массива (HEX)
    mov ah, 09h
    mov dx, msg_input
    int 21h

    mov cx, [count]
    mov bx, array
input_loop:
    call input_hex_byte ; Ввод 2 символов HEX -> байт в AL
    mov [bx], al
    inc bx
    mov ah, 02h
    mov dl, ' '
    int 21h
    loop input_loop

    ; 2. Подсчет элементов > 11h
    mov cx, [count]
    mov bx, array
    xor si, si          ; SI будет счетчиком результата

count_loop:
    mov al, [bx]
    cmp al, [threshold] ; Сравниваем значение с 11h
    jbe .next           ; Если ниже или равно (Below or Equal), пропускаем
    inc si              ; Если выше (Above), увеличиваем счетчик
.next:
    inc bx
    loop count_loop

    ; 3. Вывод результата
    mov ah, 09h
    mov dx, msg_res
    int 21h

    mov ax, si
    add al, '0'         ; Преобразуем число в ASCII
    mov dl, al
    mov ah, 02h
    int 21h

    ; 4. Выход
    mov ah, 09h
    mov dx, msg_pause
    int 21h
    mov ah, 08h
    int 21h
    mov ax, 4C00h
    int 21h

;--- Процедура ввода HEX-байта ---
input_hex_byte:
    push cx
    mov ah, 01h
    int 21h
    call char_to_hex
    shl al, 4
    mov cl, al
    mov ah, 01h
    int 21h
    call char_to_hex
    or al, cl
    pop cx
    ret

char_to_hex:
    cmp al, '9'
    jbe .is_digit
    and al, 0DFh
    sub al, 'A'-10
    ret
.is_digit:
    sub al, '0'
    ret


! Описание:
Goto: 168

! Как работает:

use16                   ; Использовать 16-битный режим (стандарт для DOS)
org 100h                ; Смещение 100h — начало программы в памяти для .COM файлов

    jmp start           ; Прыжок в начало программы, чтобы пропустить блок данных

;-- Блок данных в оперативной памяти --------------------------------
msg_input  db 'Enter 8 hex values (00-FF, e.g. 05 12 A0):', 13, 10, '$' ; Приглашение к вводу
msg_res    db 13, 10, 'Count of elements > 11h: ', '$' ; Сообщение результата
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$' ; Сообщение для паузы
array      db 8 dup(0)  ; Выделение 8 байт под исходный массив, изначально там нули
count      dw 8         ; Слово (2 байта) со значением 8 — размер массива
threshold  db 11h       ; Байт со значением 11h (17 в десятичной) — порог сравнения

;-- Основной код программы ------------------------------------------
start:
    ; 1. Ввод исходного массива (HEX)
    mov ah, 09h         ; Функция DOS 09h: вывод строки на экран
    mov dx, msg_input   ; Загрузка адреса строки приглашения в DX
    int 21h             ; Прерывание DOS — печать текста

    mov cx, [count]     ; Записываем 8 в CX — это счетчик итераций для LOOP
    mov bx, array       ; Записываем адрес начала массива в регистр BX
input_loop:
    call input_hex_byte ; Вызов подпрограммы: читает 2 символа и возвращает число в AL
    mov [bx], al        ; Записываем полученное число в память по адресу в BX
    inc bx              ; Увеличиваем адрес в BX на 1, чтобы перейти к следующему элементу
    
    mov ah, 02h         ; Функция DOS 02h: вывод одного символа
    mov dl, ' '         ; Помещаем символ пробела в DL
    int 21h             ; Печать пробела в консоли
    loop input_loop     ; Уменьшаем CX на 1. Если CX > 0, прыгаем в начало цикла

    ; 2. Подсчет элементов > 11h
    mov cx, [count]     ; Снова настраиваем CX на 8 повторений
    mov bx, array       ; Снова ставим указатель BX на начало массива
    xor si, si          ; Обнуляем регистр SI. В нем будем хранить количество найденных элементов

count_loop:
    mov al, [bx]        ; Копируем текущий байт из массива (по адресу BX) в AL
    cmp al, [threshold] ; Сравниваем значение в AL со значением 11h из памяти
    jbe .next           ; Если AL <= 11h (Below or Equal), прыгаем на метку .next
    inc si              ; Если AL > 11h, увеличиваем наш счетчик SI на 1
.next:
    inc bx              ; Сдвигаем указатель BX на следующий элемент массива
    loop count_loop     ; Повторяем цикл, пока CX не станет равен 0

    ; 3. Вывод результата
    mov ah, 09h         ; Выводим строку с текстом результата
    mov dx, msg_res
    int 21h

    mov ax, si          ; Копируем накопленный счетчик из SI в AX
    add al, '0'         ; Превращаем цифру (например, 4) в символ ASCII (код '4')
    mov dl, al          ; Кладём символ в DL для вывода через DOS
    mov ah, 02h         ; Функция вывода одного символа
    int 21h             ; Печать цифры-результата

    ; 4. Выход
    mov ah, 09h         ; Вывод строки паузы
    mov dx, msg_pause
    int 21h
    mov ah, 08h         ; Функция DOS 08h: ждать нажатия клавиши
    int 21h             ; Программа замирает до нажатия кнопки
    mov ax, 4C00h       ; Завершение работы программы
    int 21h             ; Возврат в DOS/командную строку

;--- Подпрограмма ввода байта в формате HEX (из 2-х символов) ---
input_hex_byte:
    push cx             ; Сохраняем CX в стек, чтобы не испортить счетчик цикла
    mov ah, 01h         ; Функция DOS 01h: ввод 1-го символа
    int 21h             ; Символ попадает в AL
    call char_to_hex    ; Превращаем 'A' в 10, '1' в 1 и т.д.
    shl al, 4           ; Сдвигаем значение влево на 4 бита (делаем его старшей цифрой)
    mov cl, al          ; Временно сохраняем в CL
    
    mov ah, 01h         ; Функция DOS 01h: ввод 2-го символа
    int 21h
    call char_to_hex    ; Превращаем символ во второе число
    or al, cl           ; Соединяем старшую и младшую цифры в один байт
    pop cx              ; Возвращаем CX из стека
    ret                 ; Возвращаемся в основную программу

;--- Подпрограмма конвертации символа ASCII в число 0-15 ---
char_to_hex:
    cmp al, '9'         ; Проверяем: это цифра?
    jbe .is_digit       ; Если AL <= '9', идем на метку .is_digit
    and al, 0DFh        ; Маленькие буквы a-f превращаем в заглавные A-F
    sub al, 'A'-10      ; Конвертируем 'A' -> 10, 'B' -> 11 и т.д.
    ret
.is_digit:
    sub al, '0'         ; Конвертируем '0' -> 0, '9' -> 9
    ret
