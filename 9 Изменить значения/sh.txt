use16
org 100h

    jmp start

;-- Данные ----------------------------------------------------------
msg_input  db 'Enter 8 single digits (use - for negative):', 13, 10, '$'
msg_orig   db 13, 10, 'Original array: ', '$'
msg_res    db 13, 10, 'Result (negated elements): ', '$'
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$'

array      db 8 dup(0)
count      dw 8
;--------------------------------------------------------------------

start:
    ; 1. Ввод исходного массива
    mov ah, 09h
    mov dx, msg_input
    int 21h

    mov cx, [count]     ; Счётчик цикла
    mov bx, array
input_loop:
    mov ah, 01h         ; Функция ввода символа
    int 21h
    
    cmp al, '-'         ; Обработка знака минус
    jne .pos
    int 21h             ; Читаем цифру после минуса
    sub al, '0'
    neg al              ; Делаем число отрицательным
    jmp .save
.pos:
    sub al, '0'
.save:
    mov [bx], al        ; Сохраняем байт в массив
    inc bx
    
    mov ah, 02h         ; Пробел для удобства ввода
    mov dl, ' '
    int 21h
    loop input_loop

    ; 2. Вывод оригинального массива
    mov ah, 09h
    mov dx, msg_orig
    int 21h
    call print_array

    ; 3. Изменение знака (инверсия) всех элементов
    mov cx, [count]
    mov bx, array
neg_loop:
    mov al, [bx]        ; Берем число из памяти
    neg al              ; Меняем знак: положительное -> отрицательное и наоборот
    mov [bx], al        ; Записываем обратно
    inc bx
    loop neg_loop       ; Повторяем для всех 8 элементов

    ; 4. Вывод измененного массива
    mov ah, 09h
    mov dx, msg_res
    int 21h
    call print_array

    ; 5. Пауза и выход
    mov ah, 09h
    mov dx, msg_pause
    int 21h
    mov ah, 08h         ; Ожидание нажатия любой клавиши
    int 21h
    mov ax, 4C00h       ; Завершение программы
    int 21h

;-- Подпрограмма вывода массива -------------------------------------
print_array:
    push cx
    push bx
    mov cx, [count]
    mov bx, array
.lp:
    mov al, [bx]
    cmp al, 0
    jge .p              ; Если число положительное, пропускаем знак минуса
    
    push ax
    mov dl, '-'         ; Вывод символа '-'
    mov ah, 02h
    int 21h
    pop ax
    neg al              ; Превращаем в положительное для вывода цифры
.p:
    add al, '0'         ; Превращаем число в ASCII-символ
    mov dl, al
    mov ah, 02h         ; Вывод символа на экран
    int 21h
    
    mov dl, ' '         ; Пробел между числами
    int 21h
    inc bx
    loop .lp
    pop bx
    pop cx
    ret


! Описание:
Goto: 154

! Вводи: 5, -2, 0, 7, -9, 1, -4, 3

! Как работает:

use16                   ; Использовать 16-битный режим (совместимость с DOS)
org 100h                ; Смещение 100h — стандарт для программ .COM формата

    jmp start           ; Безусловный переход на метку start, чтобы пропустить данные

;-- Блок данных в оперативной памяти --------------------------------
msg_input  db 'Enter 8 single digits (use - for negative):', 13, 10, '$' ; Строка приглашения
msg_orig   db 13, 10, 'Original array: ', '$'        ; Заголовок для вывода оригинала
msg_res    db 13, 10, 'Result (negated elements): ', '$' ; Заголовок для результата
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$' ; Текст паузы

array      db 8 dup(0)  ; Выделяем 8 байт (8 ячеек) в памяти под массив, заполняем нулями
count      dw 8         ; Переменная (слово), хранящая размер массива
;--------------------------------------------------------------------

start:
    ; 1. Ввод исходного массива
    mov ah, 09h         ; Функция DOS 09h: вывод строки, адрес которой в DX
    mov dx, msg_input   ; Загружаем адрес сообщения в регистр DX
    int 21h             ; Вызываем прерывание DOS

    mov cx, [count]     ; Записываем число 8 в счетчик циклов CX
    mov bx, array       ; Устанавливаем указатель BX на начало массива в памяти
input_loop:
    mov ah, 01h         ; Функция DOS 01h: считать один символ с клавиатуры
    int 21h             ; Код символа попадает в регистр AL
    
    cmp al, '-'         ; Сравниваем введенный символ со знаком минус
    jne .pos            ; Если не равно (т.е. ввели цифру), прыгаем на метку .pos
    int 21h             ; Если ввели '-', вызываем ввод еще раз для самой цифры
    sub al, '0'         ; Переводим ASCII-символ цифры в реальное число (например, '5' -> 5)
    neg al              ; Делаем число отрицательным (применяем операцию NEG)
    jmp .save           ; Прыгаем к сохранению, минуя блок положительного числа
.pos:
    sub al, '0'         ; Конвертируем ASCII символ положительной цифры в число
.save:
    mov [bx], al        ; Записываем итоговое число в память по адресу, на который указывает BX
    inc bx              ; Сдвигаем указатель BX на 1 байт вперед для следующего элемента
    
    mov ah, 02h         ; Функция DOS 02h: вывод одного символа
    mov dl, ' '         ; Кладем символ пробела в DL
    int 21h             ; Печатаем пробел в консоли
    loop input_loop     ; Уменьшаем CX на 1. Если CX не ноль, возвращаемся в input_loop

    ; 2. Вывод оригинального массива
    mov ah, 09h         ; Печатаем заголовок "Original array"
    mov dx, msg_orig
    int 21h
    call print_array    ; Вызываем подпрограмму печати всех элементов массива

    ; 3. Изменение знака (инверсия) всех элементов
    mov cx, [count]     ; Снова настраиваем цикл на 8 итераций
    mov bx, array       ; Снова ставим BX на начало массива
neg_loop:
    mov al, [bx]        ; Копируем текущий байт из памяти в регистр AL
    neg al              ; МЕНЯЕМ ЗНАК: если было 5, станет -5; если было -3, станет 3
    mov [bx], al        ; Записываем измененное число обратно в ту же ячейку памяти
    inc bx              ; Переходим к следующей ячейке (адресу)
    loop neg_loop       ; Повторяем процедуру для всех элементов массива

    ; 4. Вывод измененного массива
    mov ah, 09h         ; Печатаем заголовок "Result..."
    mov dx, msg_res
    int 21h
    call print_array    ; Печатаем массив, в котором все числа сменили знак

    ; 5. Пауза и выход
    mov ah, 09h         ; Печатаем сообщение "Press any key..."
    mov dx, msg_pause
    int 21h
    mov ah, 08h         ; Функция DOS 08h: чтение клавиши без вывода на экран (пауза)
    int 21h
    mov ax, 4C00h       ; Завершение программы и передача управления ОС
    int 21h

;-- Подпрограмма вывода массива (из BX) -----------------------------
print_array:
    push cx             ; Сохраняем значения регистров в стек, чтобы не испортить их
    push bx
    mov cx, [count]     ; Цикл на 8 раз
    mov bx, array       ; Указатель на начало массива
.lp:
    mov al, [bx]        ; Читаем число из массива в AL
    cmp al, 0           ; Проверяем: оно положительное или отрицательное?
    jge .p              ; Если >= 0 (Jump if Greater or Equal), прыгаем к печати цифры
    
    push ax             ; Если < 0, сохраняем число в стек
    mov dl, '-'         ; Выводим символ минуса перед цифрой
    mov ah, 02h
    int 21h
    pop ax              ; Достаем число обратно в AL
    neg al              ; Делаем его положительным, чтобы правильно вывести символ цифры
.p:
    add al, '0'         ; Конвертируем число в ASCII-код цифры (например, 5 -> 35h)
    mov dl, al          ; Кладём в DL для вывода через DOS
    mov ah, 02h
    int 21h             ; Выводим саму цифру
    
    mov dl, ' '         ; Выводим пробел после каждого числа
    int 21h
    inc bx              ; Сдвигаем указатель к следующему элементу
    loop .lp            ; Крутим цикл печати
    pop bx              ; Восстанавливаем сохраненные значения регистров из стека
    pop cx
    ret                 ; Возвращаемся в точку, откуда была вызвана процедура
