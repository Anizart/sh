use16
org 100h

    jmp start

;-- Данные ----------------------------------------------------------
msg_input  db 'Enter 8 single digits (0-9):', 13, 10, '$'
msg_orig   db 13, 10, 'Original array: ', '$'
msg_res    db 13, 10, 'Result (elements - 1): ', '$'
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$'

array      db 8 dup(0)
count      dw 8
;--------------------------------------------------------------------

start:
    ; 1. Ввод исходного массива
    mov ah, 09h
    mov dx, msg_input
    int 21h

    mov cx, [count]     ; Счётчик цикла
    mov bx, array       ; Указатель на начало массива
input_loop:
    mov ah, 01h         ; Ввод символа
    int 21h
    sub al, '0'         ; ASCII -> Число
    mov [bx], al        ; Сохраняем в память
    
    inc bx
    mov ah, 02h         ; Пробел
    mov dl, ' '
    int 21h
    loop input_loop

    ; 2. Вывод оригинального массива
    mov ah, 09h
    mov dx, msg_orig
    int 21h
    call print_array

    ; 3. Уменьшение каждого элемента на 1
    mov cx, [count]
    mov bx, array
decrement_loop:
    mov al, [bx]        ; Берем число из памяти
    dec al              ; Уменьшаем на 1
    mov [bx], al        ; Записываем обратно
    inc bx
    loop decrement_loop ; Повторяем для всех элементов

    ; 4. Вывод измененного массива
    mov ah, 09h
    mov dx, msg_res
    int 21h
    call print_array

    ; 5. Пауза и выход
    mov ah, 09h
    mov dx, msg_pause
    int 21h
    mov ah, 08h         ; Ожидание нажатия клавиши
    int 21h
    mov ax, 4C00h       ; Завершение программы
    int 21h

;-- Подпрограмма вывода массива -------------------------------------
print_array:
    push cx
    push bx
    mov cx, [count]
    mov bx, array
.lp:
    mov al, [bx]
    
    ; Обработка отрицательных чисел (если ввели 0, станет -1)
    cmp al, 0
    jge .positive
    push ax
    mov dl, '-'         ; Вывод знака минус
    mov ah, 02h
    int 21h
    pop ax
    neg al              ; Для вывода цифры

.positive:
    add al, '0'         ; Число -> ASCII
    mov dl, al
    mov ah, 02h
    int 21h
    
    mov dl, ' '         ; Пробел
    int 21h
    inc bx
    loop .lp
    pop bx
    pop cx
    ret


! Описание:
Goto: 16C

! Вводи: 5 1 0 8 3 6 2 4

! Как работает:

use16                   ; Указываем компилятору использовать 16-битный режим (DOS)
org 100h                ; Смещение 100h — стандартное начало для .COM программ в памяти

    jmp start           ; Прыжок на метку start, чтобы пропустить данные и не исполнять их как код

;-- Данные в оперативной памяти -------------------------------------
msg_input  db 'Enter 8 single digits (0-9):', 13, 10, '$' ; Строка приглашения (13, 10 — новая строка)
msg_orig   db 13, 10, 'Original array: ', '$'             ; Заголовок для вывода начального массива
msg_res    db 13, 10, 'Result (elements - 1): ', '$'      ; Заголовок для вывода результата
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$' ; Сообщение о паузе перед выходом

array      db 8 dup(0)  ; Выделяем 8 байт (ячеек) памяти, изначально заполненных нулями
count      dw 8         ; Переменная (слово), хранящая количество элементов (8)
;--------------------------------------------------------------------

start:
    ; 1. Ввод исходного массива с клавиатуры
    mov ah, 09h         ; Функция DOS 09h: вывод строки на экран
    mov dx, msg_input   ; Загружаем в DX адрес строки приглашения
    int 21h             ; Вызываем прерывание DOS для печати

    mov cx, [count]     ; Записываем число 8 в счетчик циклов CX
    mov bx, array       ; Записываем адрес начала массива в регистр-указатель BX
input_loop:
    mov ah, 01h         ; Функция DOS 01h: ввод 1 символа с клавиатуры (символ в AL)
    int 21h             ; Системный вызов
    sub al, '0'         ; Переводим ASCII-код символа (например, 31h) в число (1)
    mov [bx], al        ; Копируем число из регистра AL в ячейку памяти по адресу в BX
    
    inc bx              ; Увеличиваем адрес в BX на 1, чтобы перейти к следующему байту
    mov ah, 02h         ; Функция DOS 02h: вывод одного символа на экран
    mov dl, ' '         ; Записываем символ пробела в DL
    int 21h             ; Печатаем пробел между вводимыми цифрами
    loop input_loop     ; Уменьшаем CX на 1. Если CX > 0, прыгаем обратно в input_loop

    ; 2. Вывод оригинального (введенного) массива
    mov ah, 09h         ; Печать заголовка msg_orig
    mov dx, msg_orig
    int 21h
    call print_array    ; Вызываем подпрограмму вывода массива на экран

    ; 3. Уменьшение каждого элемента на 1
    mov cx, [count]     ; Снова устанавливаем счетчик цикла на 8
    mov bx, array       ; Устанавливаем указатель BX на начало массива
decrement_loop:
    mov al, [bx]        ; Читаем значение из памяти (адрес в BX) в регистр AL
    dec al              ; Команда DEC: уменьшаем число в AL на единицу (AL = AL - 1)
    mov [bx], al        ; Записываем измененное число из AL обратно в ту же ячейку памяти
    inc bx              ; Сдвигаем указатель BX на следующий элемент
    loop decrement_loop ; Повторяем, пока не обработаем все 8 элементов

    ; 4. Вывод измененного массива
    mov ah, 09h         ; Печать заголовка msg_res
    mov dx, msg_res
    int 21h
    call print_array    ; Вызываем подпрограмму для показа результата

    ; 5. Пауза и выход
    mov ah, 09h         ; Печать сообщения о паузе
    mov dx, msg_pause
    int 21h
    mov ah, 08h         ; Функция DOS 08h: ожидание нажатия любой клавиши
    int 21h             ; Программа "замрет", пока не нажмете кнопку
    mov ax, 4C00h       ; Функция DOS 4Ch: корректное завершение программы
    int 21h             ; Выход в операционную систему

;-- Подпрограмма вывода массива (выводит элементы по адресу из BX) --
print_array:
    push cx             ; Сохраняем текущие значения CX и BX в стек, 
    push bx             ; чтобы не испортить их для основной программы
    mov cx, [count]     ; Цикл на 8 итераций
    mov bx, array       ; Начинаем с начала массива
.lp:
    mov al, [bx]        ; Читаем число из памяти в AL
    
    ; Проверка на отрицательное число (если было 0, стало -1)
    cmp al, 0           ; Сравниваем число с нулем
    jge .positive       ; Если число >= 0, переходим к метке .positive
    push ax             ; Если число < 0, сохраняем его
    mov dl, '-'         ; Выводим символ минуса
    mov ah, 02h
    int 21h
    pop ax              ; Достаем число обратно
    neg al              ; Меняем знак (из -1 получаем 1), чтобы вывести цифру


.positive:
    add al, '0'         ; Превращаем число (1) в ASCII-символ ('1' или 31h)
    mov dl, al          ; Кладём в DL для вывода
    mov ah, 02h         ; Функция вывода символа
    int 21h             ; Печать цифры
    
    mov dl, ' '         ; Печать пробела после цифры
    int 21h
    inc bx              ; Переход к следующему байту в памяти
    loop .lp            ; Крутим цикл печати
    pop bx              ; Восстанавливаем сохраненные значения из стека
    pop cx
    ret                 ; Возвращаемся в основную программу
