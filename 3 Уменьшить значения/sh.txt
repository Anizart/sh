use16
org 100h

    jmp start

;-- Данные ----------------------------------------------------------
msg_input  db 'Enter 8 digits (use - for negative):', 13, 10, '$'
msg_orig   db 13, 10, 'Original array: ', '$'
msg_res    db 13, 10, 'Result (positives - 2): ', '$'
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$'

array      db 8 dup(0)
count      dw 8
;--------------------------------------------------------------------

start:
    ; 1. Ввод массива (цифры 0-9 и отрицательные)
    mov ah, 09h
    mov dx, msg_input
    int 21h

    mov cx, [count]
    mov bx, array
input_loop:
    mov ah, 01h
    int 21h
    cmp al, '-'         ; Обработка знака минус
    jne .pos
    int 21h
    sub al, '0'
    neg al
    jmp .save
.pos:
    sub al, '0'
.save:
    mov [bx], al        ; Сохраняем в память
    inc bx
    mov ah, 02h
    mov dl, ' '
    int 21h
    loop input_loop

    ; 2. Вывод исходного массива
    mov ah, 09h
    mov dx, msg_orig
    int 21h
    call print_array

    ; 3. Обработка: если элемент > 0, то элемент = элемент - 2
    mov cx, [count]
    mov bx, array
process_loop:
    mov al, [bx]        ; Берем число из памяти
    cmp al, 0           ; Сравниваем с нулем
    jle .skip           ; Если <= 0 (Jump if Less or Equal), пропускаем
    
    sub al, 2           ; Вычитаем 2
    mov [bx], al        ; Записываем обратно

.skip:
    inc bx
    loop process_loop

    ; 4. Вывод измененного массива
    mov ah, 09h
    mov dx, msg_res
    int 21h
    call print_array

    ; 5. Выход
    mov ah, 09h
    mov dx, msg_pause
    int 21h
    mov ah, 08h
    int 21h
    mov ax, 4C00h
    int 21h

;-- Подпрограмма вывода массива -------------------------------------
print_array:
    push cx
    push bx
    mov cx, [count]
    mov bx, array
.lp:
    mov al, [bx]
    test al, al         ; Проверка знака для вывода
    jns .p
    push ax
    mov dl, '-'
    mov ah, 02h
    int 21h
    pop ax
    neg al
.p:
    add al, '0'         ; Преобразование в ASCII
    mov dl, al
    mov ah, 02h
    int 21h
    mov dl, ' '
    int 21h
    inc bx
    loop .lp
    pop bx
    pop cx
    ret


! Описание:
Goto: 174

! Как работает:

use16                   ; Использовать 16-битный режим (стандарт для DOS)
org 100h                ; Смещение 100h — начало программы в памяти для .COM файлов

    jmp start           ; Безусловный прыжок на метку start, чтобы пропустить данные

;-- Данные программы в оперативной памяти ---------------------------
msg_input  db 'Enter 8 digits (use - for negative):', 13, 10, '$' ; Текст приглашения
msg_orig   db 13, 10, 'Original array: ', '$'                    ; Заголовок для вывода оригинала
msg_res    db 13, 10, 'Result (positives - 2): ', '$'             ; Заголовок для вывода результата
msg_pause  db 13, 10, 13, 10, 'Press any key to exit...', '$'     ; Текст паузы

array      db 8 dup(0)  ; Резервируем 8 байт памяти под массив, заполняем нулями
count      dw 8         ; Переменная (слово) хранящая размер массива (8)

;-- Основной код ----------------------------------------------------
start:
    ; 1. Ввод массива с клавиатуры
    mov ah, 09h         ; Функция DOS 09h: вывод строки на экран
    mov dx, msg_input   ; Загружаем в DX адрес строки приглашения
    int 21h             ; Системный вызов DOS

    mov cx, [count]     ; Копируем значение 8 в счетчик циклов CX
    mov bx, array       ; Записываем адрес начала массива в регистр-указатель BX
input_loop:
    mov ah, 01h         ; Функция DOS 01h: чтение символа с клавиатуры
    int 21h             ; Код символа попадает в регистр AL
    cmp al, '-'         ; Сравниваем введенный символ со знаком минус '-'
    jne .pos            ; Если это не минус (Jump if Not Equal), прыгаем на .pos
    int 21h             ; Если был минус, вызываем прерывание еще раз, чтобы считать саму цифру
    sub al, '0'         ; Переводим цифру из кода ASCII в число (вычитаем 30h)
    neg al              ; Делаем число отрицательным (инверсия знака)
    jmp .save           ; Прыгаем к сохранению, пропуская обработку положительного числа
.pos:
    sub al, '0'         ; Для положительной цифры: перевод ASCII -> Число
.save:
    mov [bx], al        ; Записываем готовое число из AL в память по адресу в BX
    inc bx              ; Увеличиваем адрес в BX на 1 байт (переход к следующей ячейке)
    mov ah, 02h         ; Функция DOS 02h: вывод символа
    mov dl, ' '         ; Выводим пробел между вводами для удобства
    int 21h             ; Системный вызов
    loop input_loop     ; Уменьшаем CX на 1. Если CX > 0, идем на новый круг input_loop

    ; 2. Вывод оригинального массива (для контроля)
    mov ah, 09h         ; Вывод заголовка msg_orig
    mov dx, msg_orig
    int 21h
    call print_array    ; Вызов подпрограммы печати всех элементов массива

    ; 3. Главная обработка: уменьшение положительных на 2
    mov cx, [count]     ; Снова настраиваем цикл на 8 итераций
    mov bx, array       ; Снова ставим указатель BX на начало массива
process_loop:
    mov al, [bx]        ; Читаем байт из памяти (адрес в BX) в регистр AL
    cmp al, 0           ; Сравниваем число в AL с нулем
    jle .skip           ; Если число <= 0 (Jump if Less or Equal), прыгаем на .skip
    
    sub al, 2           ; Если число было > 0, вычитаем из него 2
    mov [bx], al        ; Сохраняем измененное число обратно в ту же ячейку памяти

.skip:
    inc bx              ; Переходим к адресу следующего элемента в массиве
    loop process_loop   ; Повторяем цикл для всех элементов массива

    ; 4. Вывод измененного массива
    mov ah, 09h         ; Вывод заголовка msg_res
    mov dx, msg_res
    int 21h
    call print_array    ; Снова вызываем подпрограмму печати для отображения изменений

    ; 5. Завершение работы
    mov ah, 09h         ; Вывод сообщения о паузе
    mov dx, msg_pause
    int 21h
    mov ah, 08h         ; Функция DOS 08h: ожидание нажатия клавиши
    int 21h
    mov ax, 4C00h       ; Функция DOS 4Ch: корректное завершение программы
    int 21h

;-- Подпрограмма печати массива -------------------------------------
print_array:
    push cx             ; Сохраняем текущие значения регистров в стек, чтобы не испортить
    push bx
    mov cx, [count]     ; Количество элементов для печати
    mov bx, array       ; Указатель на начало массива
.lp:
    mov al, [bx]        ; Берем число из памяти в AL
    test al, al         ; Проверяем число на знак
    jns .p              ; Если число положительное (Jump if Not Signed), прыгаем на .p
    push ax             ; Если число отрицательное: сохраняем AX
    mov dl, '-'         ; Выводим знак минуса '-'
    mov ah, 02h
    int 21h
    pop ax              ; Возвращаем число в AX
    neg al              ; Делаем число положительным для печати цифры
.p:
    add al, '0'         ; Переводим число обратно в ASCII-код цифры
    mov dl, al          ; Кладём в DL для вывода
    mov ah, 02h
    int 21h             ; Печать цифры
    mov dl, ' '         ; Печать пробела
    int 21h
    inc bx              ; Переход к следующему байту
    loop .lp            ; Повторяем, пока не напечатаем все 8 чисел
    pop bx              ; Восстанавливаем сохраненные значения из стека
    pop cx
    ret                 ; Возвращаемся в точку вызова подпрограммы
